{
  "metadata": {
    "name": "New JSNB",
    "language_info": {
      "name": "JavaScipt",
      "version": "8.0"
    }
  },
  "jsnbversion": "v0.1",
  "cells": [
    {
      "code": "# 3D Math Visualizer\n\n## Overview\nThe **3D Math Visualizer** is a standalone JavaScript tool designed to render and interact with 3D mathematical objects using **A-Frame**. It supports visualizing vectors, explicit surfaces, parametric surfaces, and implicit surfaces in real-time, making it ideal for educational and exploratory purposes.\n\n---\n\n## Key Features\n\n### **Vector Visualization**\n- Add 3D vectors with customizable components and colors.\n- Proper alignment using quaternion-based rotation.\n\n### **Explicit Surfaces**\n- Render surfaces defined by `z = f(x, y)` with adjustable range, resolution, and color.\n\n### **Parametric Surfaces**\n- Define surfaces using parametric equations `x(u, v)`, `y(u, v)`, `z(u, v)` with customizable parameter ranges.\n\n### **Implicit Surfaces**\n- Render surfaces defined by `f(x, y, z) = 0` using:\n  - Parametric conversion, or\n  - The Marching Cubes algorithm (for unsupported functions).\n\n### **Grid and Axes**\n- 3D gridlines in **XY**, **YZ**, and **ZX** planes for spatial reference.\n- Always-visible **X**, **Y**, **Z** axes with labeled markers.\n\n### **Camera Controls**\n- Orbit, zoom, and pan controls with reset functionality.\n\n### **Math Expression Evaluation**\n- Uses **Math.js** for evaluating mathematical expressions.\n- Supports advanced functions and constants.\n\n### **Object Management**\n- Add, remove, and clear objects programmatically.\n\n---\n\n## Motivation\nThe project aims to make abstract mathematical concepts tangible by providing an interactive 3D environment. It is designed for **educators**, **students**, and **enthusiasts** to explore and visualize mathematical operations and surfaces intuitively.\n\n---\n\n## Summary\nThe **3D Math Visualizer** combines **A-Frame** for rendering and **Math.js** for computation, offering a robust platform for 3D mathematical visualization. It is a versatile tool for **education**, **experimentation**, and **exploration** of mathematical concepts.\n",
      "status": "",
      "output": "<h1>3D Math Visualizer</h1>\n<h2>Overview</h2>\n<p>The <strong>3D Math Visualizer</strong> is a standalone JavaScript tool designed to render and interact with 3D mathematical objects using <strong>A-Frame</strong>. It supports visualizing vectors, explicit surfaces, parametric surfaces, and implicit surfaces in real-time, making it ideal for educational and exploratory purposes.</p>\n<hr>\n<h2>Key Features</h2>\n<h3><strong>Vector Visualization</strong></h3>\n<ul>\n<li>Add 3D vectors with customizable components and colors.</li>\n<li>Proper alignment using quaternion-based rotation.</li>\n</ul>\n<h3><strong>Explicit Surfaces</strong></h3>\n<ul>\n<li>Render surfaces defined by <code>z = f(x, y)</code> with adjustable range, resolution, and color.</li>\n</ul>\n<h3><strong>Parametric Surfaces</strong></h3>\n<ul>\n<li>Define surfaces using parametric equations <code>x(u, v)</code>, <code>y(u, v)</code>, <code>z(u, v)</code> with customizable parameter ranges.</li>\n</ul>\n<h3><strong>Implicit Surfaces</strong></h3>\n<ul>\n<li>Render surfaces defined by <code>f(x, y, z) = 0</code> using:<ul>\n<li>Parametric conversion, or</li>\n<li>The Marching Cubes algorithm (for unsupported functions).</li>\n</ul>\n</li>\n</ul>\n<h3><strong>Grid and Axes</strong></h3>\n<ul>\n<li>3D gridlines in <strong>XY</strong>, <strong>YZ</strong>, and <strong>ZX</strong> planes for spatial reference.</li>\n<li>Always-visible <strong>X</strong>, <strong>Y</strong>, <strong>Z</strong> axes with labeled markers.</li>\n</ul>\n<h3><strong>Camera Controls</strong></h3>\n<ul>\n<li>Orbit, zoom, and pan controls with reset functionality.</li>\n</ul>\n<h3><strong>Math Expression Evaluation</strong></h3>\n<ul>\n<li>Uses <strong>Math.js</strong> for evaluating mathematical expressions.</li>\n<li>Supports advanced functions and constants.</li>\n</ul>\n<h3><strong>Object Management</strong></h3>\n<ul>\n<li>Add, remove, and clear objects programmatically.</li>\n</ul>\n<hr>\n<h2>Motivation</h2>\n<p>The project aims to make abstract mathematical concepts tangible by providing an interactive 3D environment. It is designed for <strong>educators</strong>, <strong>students</strong>, and <strong>enthusiasts</strong> to explore and visualize mathematical operations and surfaces intuitively.</p>\n<hr>\n<h2>Summary</h2>\n<p>The <strong>3D Math Visualizer</strong> combines <strong>A-Frame</strong> for rendering and <strong>Math.js</strong> for computation, offering a robust platform for 3D mathematical visualization. It is a versatile tool for <strong>education</strong>, <strong>experimentation</strong>, and <strong>exploration</strong> of mathematical concepts.</p>\n",
      "type": "html"
    },
    {
      "code": "NOTE: RUN THE BELOW CELL TWICE AND THEN RUN THE CELL AFTER IT",
      "status": "",
      "output": "<p>NOTE: RUN THE BELOW CELL TWICE AND THEN RUN THE CELL AFTER IT</p>\n",
      "type": "html"
    },
    {
      "code": "// 3D Math Visualizer for Scribbler Notebooks\n// Uses A-Frame for 3D rendering\n\n//**********************************************************************\n// Main Visualizer Setup Function\n//**********************************************************************\n\nfunction createMathVisualizer(containerId = 'math-visualizer') {\n    // Create the main container\n    const container = document.getElementById(containerId) || document.createElement('div');\n    container.id = containerId;\n    container.style.cssText = `\n        width: 100%;\n        height: 600px;\n        position: relative;\n        background: #1a1a1a;\n        border-radius: 8px;\n        overflow: hidden;    `;\n      // Add A-Frame script if not already loaded\n    if (!window.AFRAME) {\n        const script = document.createElement('script');\n        script.src = 'https://aframe.io/releases/1.4.0/aframe.min.js';\n        document.head.appendChild(script);\n        \n        // Add custom orbit-controls component when script loads        script.onload = function() {            // Register the improved rotation-watcher component to fix axes visibility\n            if (!AFRAME.components['rotation-watcher']) {\n                AFRAME.registerComponent('rotation-watcher', {\n                    init: function() {\n                        this.originalVisibility = this.el.getAttribute('visible') !== false;\n                        this.tick = AFRAME.utils.throttleTick(this.tick, 30, this); // Faster tick rate for better responsiveness\n                        \n                        // Store reference to the object3D for faster access\n                        this.object3D = this.el.object3D;\n                        \n                        // Track camera movements to ensure visibility during rotation\n                        const sceneEl = document.querySelector('a-scene');\n                        if (sceneEl) {\n                            sceneEl.addEventListener('camerachange', () => {\n                                this.forceVisible();\n                            });\n                            \n                            // Also listen for render events\n                            sceneEl.addEventListener('render-target-loaded', () => {\n                                this.forceVisible();\n                            });\n                        }\n                        \n                        // Initial visibility enforcement\n                        this.forceVisible();\n                    },\n                    tick: function() {\n                        this.forceVisible();\n                    },\n                    forceVisible: function() {\n                        // Force visibility regardless of camera position or rotation\n                        if (this.object3D) {\n                            if (this.object3D.visible !== this.originalVisibility) {\n                                this.object3D.visible = this.originalVisibility;\n                            }\n                            \n                            // Ensure higher render order to prevent occlusion issues\n                            this.object3D.renderOrder = 2000; // Increased from 1000 for better visibility\n                            \n                            // Apply to all children recursively with more aggressive settings\n                            this.object3D.traverse((child) => {\n                                if (child.isMesh) {\n                                    child.renderOrder = 2000;\n                                    child.material.depthTest = false; // Changed to false to render on top\n                                    child.material.transparent = true;\n                                    child.material.opacity = child.material.opacity || 1.0;\n                                    child.material.needsUpdate = true;\n                                    child.frustumCulled = false; // Prevent culling when outside frustum\n                                }\n                            });\n                        }\n                    }\n                });\n            }\n            \n            if (!AFRAME.components['orbit-controls']) {\n                AFRAME.registerComponent('orbit-controls', {\n                    schema: {\n                        target: { type: 'vec3', default: { x: 0, y: 0, z: 0 } },\n                        enableDamping: { type: 'boolean', default: true },\n                        dampingFactor: { type: 'number', default: 0.25 },\n                        rotateSpeed: { type: 'number', default: 0.5 },\n                        minDistance: { type: 'number', default: 2 },\n                        maxDistance: { type: 'number', default: 20 },\n                        enablePan: { type: 'boolean', default: true },\n                        panSpeed: { type: 'number', default: 0.5 },\n                        minPolarAngle: { type: 'number', default: 0.2 },\n                        maxPolarAngle: { type: 'number', default: 2.5 },\n                        enableKeys: { type: 'boolean', default: true },\n                        enableZoom: { type: 'boolean', default: true },\n                        zoomSpeed: { type: 'number', default: 1.0 },\n                        enableInertia: { type: 'boolean', default: true },\n                        inertiaFactor: { type: 'number', default: 0.9 }\n                    },\n                      init: function () {\n                        this.cameraEl = this.el;\n                        this.cameraPosition = new THREE.Vector3();\n                        this.cameraRotation = new THREE.Euler();\n                        \n                        // Setup initial target (center point to orbit around)\n                        this.target = new THREE.Vector3(\n                            this.data.target.x, \n                            this.data.target.y, \n                            this.data.target.z\n                        );\n                        \n                        // State variables\n                        this.isPanning = false;\n                        this.isRotating = false;\n                        this.isZooming = false;\n                        this.wasRotating = false;\n                        this.wasPanning = false;\n                        this.lastMouseX = 0;\n                        this.lastMouseY = 0;\n                        this.mouseDeltaX = 0;\n                        this.mouseDeltaY = 0;\n                        this.spherical = new THREE.Spherical();\n                        this.sphericalDelta = new THREE.Spherical();\n                        this.scale = 1;\n                        this.zoomChanged = false;\n                        this.panOffset = new THREE.Vector3();\n                        this.panSpeed = this.data.panSpeed;\n                        this.needsUpdate = true;\n                        this.lastTime = performance.now();\n                        this.velocity = { x: 0, y: 0 };\n                        \n                        // Axis-specific rotation mode\n                        this.axisRotationMode = null; // null, 'x', 'y', or 'z'\n                    \n                    \n                    // Bind methods\n                    this.onContextMenu = this.onContextMenu.bind(this);\n                    this.onMouseDown = this.onMouseDown.bind(this);\n                    this.onMouseMove = this.onMouseMove.bind(this);\n                    this.onMouseUp = this.onMouseUp.bind(this);\n                    this.onMouseWheel = this.onMouseWheel.bind(this);\n                    this.onTouchStart = this.onTouchStart.bind(this);\n                    this.onTouchMove = this.onTouchMove.bind(this);\n                    this.onTouchEnd = this.onTouchEnd.bind(this);\n                    this.onKeyDown = this.onKeyDown.bind(this);\n                    \n                    // Setup event listeners\n                    const canvas = document.querySelector('canvas');\n                    if (canvas) {\n                        canvas.addEventListener('contextmenu', this.onContextMenu, false);\n                        canvas.addEventListener('mousedown', this.onMouseDown, false);\n                        canvas.addEventListener('wheel', this.onMouseWheel, false);\n                        canvas.addEventListener('touchstart', this.onTouchStart, false);\n                        canvas.addEventListener('touchend', this.onTouchEnd, false);\n                        canvas.addEventListener('touchmove', this.onTouchMove, false);\n                        window.addEventListener('keydown', this.onKeyDown, false);\n                    }\n                    \n                    // Setup status display\n                    this.statusEl = document.createElement('div');\n                    this.statusEl.style.cssText = `\n                        position: absolute;\n                        bottom: 10px;\n                        right: 10px;\n                        background: rgba(0, 0, 0, 0.8);\n                        color: white;\n                        padding: 8px;\n                        border-radius: 5px;\n                        font-size: 11px;\n                        z-index: 1000;\n                        display: none;\n                    `;\n                    document.body.appendChild(this.statusEl);\n                    \n                    // Initialize camera position\n                    this.updateCamera();\n                },\n                \n                update: function() {\n                    this.target.set(this.data.target.x, this.data.target.y, this.data.target.z);\n                    this.needsUpdate = true;\n                },\n                \n                remove: function() {\n                    const canvas = document.querySelector('canvas');\n                    if (canvas) {\n                        canvas.removeEventListener('contextmenu', this.onContextMenu);\n                        canvas.removeEventListener('mousedown', this.onMouseDown);\n                        canvas.removeEventListener('wheel', this.onMouseWheel);\n                        canvas.removeEventListener('touchstart', this.onTouchStart);\n                        canvas.removeEventListener('touchend', this.onTouchEnd);\n                        canvas.removeEventListener('touchmove', this.onTouchMove);\n                        window.removeEventListener('keydown', this.onKeyDown);\n                    }\n                    if (this.statusEl) {\n                        this.statusEl.remove();\n                    }\n                },\n                \n                tick: function() {\n                    // Update camera position/rotation based on controls\n                    this.updateCamera();\n                },\n                  updateCamera: function() {\n                    // Get current camera position and rotation\n                    const el = this.cameraEl;\n                    const position = el.getAttribute('position');\n                    const rotation = el.getAttribute('rotation');\n                    \n                    this.cameraPosition.set(position.x, position.y, position.z);\n                    this.cameraRotation.set(\n                        THREE.MathUtils.degToRad(rotation.x),\n                        THREE.MathUtils.degToRad(rotation.y),\n                        THREE.MathUtils.degToRad(rotation.z)\n                    );\n                    \n                    // Calculate spherical coordinates\n                    const offset = new THREE.Vector3();\n                    offset.copy(this.cameraPosition).sub(this.target);\n                    this.spherical.setFromVector3(offset);\n                      // Apply rotation delta with damping\n                    if (this.data.enableDamping) {\n                        this.spherical.theta += this.sphericalDelta.theta;\n                        this.spherical.phi += this.sphericalDelta.phi;\n                    } else {\n                        this.spherical.theta += this.sphericalDelta.theta;\n                        this.spherical.phi += this.sphericalDelta.phi;\n                    }\n                    \n                    // Apply constraints\n                    this.spherical.theta = Math.max(0, Math.min(Math.PI * 2, this.spherical.theta));\n                    this.spherical.phi = Math.max(this.data.minPolarAngle, Math.min(this.data.maxPolarAngle, this.spherical.phi));\n                    this.spherical.makeSafe();\n                    \n                    // Apply zoom with damping\n                    if (this.zoomChanged) {\n                        if (this.data.enableDamping) {\n                            this.spherical.radius *= 1 + (this.scale - 1) * this.data.dampingFactor;\n                        } else {\n                            this.spherical.radius *= this.scale;\n                        }\n                    }\n                    \n                    // Enforce min/max distances\n                    this.spherical.radius = Math.max(this.data.minDistance, Math.min(this.data.maxDistance, this.spherical.radius));\n                    \n                    // Apply pan offset with damping\n                    if (this.data.enableDamping) {\n                        this.target.addScaledVector(this.panOffset, this.data.dampingFactor);\n                    } else {\n                        this.target.add(this.panOffset);\n                    }\n                    \n                    // Convert back to Cartesian coordinates\n                    offset.setFromSpherical(this.spherical);\n                    \n                    // Recalculate camera position\n                    const newPosition = new THREE.Vector3().copy(this.target).add(offset);\n                    \n                    // Update A-Frame entity\n                    if (this.needsUpdate || \n                        !newPosition.equals(this.cameraPosition) || \n                        this.sphericalDelta.theta !== 0 || \n                        this.sphericalDelta.phi !== 0 || \n                        this.scale !== 1 || \n                        !this.panOffset.equals(new THREE.Vector3())) {\n                        \n                        el.setAttribute('position', {\n                            x: newPosition.x,\n                            y: newPosition.y,\n                            z: newPosition.z\n                        });\n                        \n                        // Look at the target\n                        const lookAtPosition = this.target.clone();\n                        el.object3D.lookAt(lookAtPosition);\n                        const lookAtRotation = el.object3D.rotation;\n                        el.setAttribute('rotation', {\n                            x: THREE.MathUtils.radToDeg(lookAtRotation.x),\n                            y: THREE.MathUtils.radToDeg(lookAtRotation.y),\n                            z: THREE.MathUtils.radToDeg(lookAtRotation.z)\n                        });\n                        \n                        this.needsUpdate = false;\n                    }\n                      // Reset deltas with damping\n                    if (this.data.enableDamping) {\n                        // Apply inertia if enabled\n                        if (this.data.enableInertia && (this.isRotating || this.isPanning)) {\n                            // Keep rotation deltas during active interaction, apply lighter damping\n                            const activeFactor = 0.95; // Much lighter damping during interaction\n                            this.sphericalDelta.theta *= activeFactor;\n                            this.sphericalDelta.phi *= activeFactor;\n                            this.panOffset.multiplyScalar(activeFactor);\n                        } else {\n                            // Standard damping when not interacting - apply stronger decay\n                            const dampFactor = this.data.dampingFactor;\n                            this.sphericalDelta.theta *= dampFactor;\n                            this.sphericalDelta.phi *= dampFactor;\n                            this.panOffset.multiplyScalar(dampFactor);\n                            \n                            // Apply inertia on release\n                            if (this.wasRotating && !this.isRotating) {\n                                this.sphericalDelta.theta *= this.data.inertiaFactor;\n                                this.sphericalDelta.phi *= this.data.inertiaFactor;\n                                this.wasRotating = false;\n                            }\n                            \n\n                            if (this.wasPanning && !this.isPanning) {\n                                this.panOffset.multiplyScalar(this.data.inertiaFactor);\n                                this.wasPanning = false;\n                            }\n                        }\n                    } else {\n                        // No damping - reset deltas after applying\n                        this.sphericalDelta.set(0, 0, 0);\n                        this.panOffset.set(0, 0, 0);\n                    }\n                    \n                    // Reset zoom state\n                    this.scale = 1;\n                    this.zoomChanged = false;\n                    \n                    // Track previous states for inertia\n                    if (this.isRotating) this.wasRotating = true;\n                    if (this.isPanning) this.wasPanning = true;\n                },\n                \n                showStatus: function(message, duration = 1000) {\n                    if (this.statusEl) {\n                        this.statusEl.textContent = message;\n                        this.statusEl.style.display = 'block';\n                        \n                        clearTimeout(this.statusTimeout);\n                        this.statusTimeout = setTimeout(() => {\n                            this.statusEl.style.display = 'none';\n                        }, duration);\n                    }\n                },\n                \n                // Event handlers\n                onContextMenu: function(event) {\n                    event.preventDefault();\n                },\n                \n                onMouseDown: function(event) {\n                    event.preventDefault();\n                    \n                    if (event.button === 0) {\n                        // Left mouse button - rotate\n                        this.isRotating = true;\n                        this.showStatus(\"Rotating\");\n                    } else if (event.button === 1 || event.button === 2) {\n                        // Middle or right mouse button - pan\n                        this.isPanning = true;\n                        this.showStatus(\"Panning\");\n                    }\n                    \n                    this.lastMouseX = event.clientX;\n                    this.lastMouseY = event.clientY;\n                    \n                    // Add document-wide event listeners\n                    document.addEventListener('mousemove', this.onMouseMove, false);\n                    document.addEventListener('mouseup', this.onMouseUp, false);\n                },\n                  onMouseMove: function(event) {\n                    event.preventDefault();\n                    \n                    const deltaX = event.clientX - this.lastMouseX;\n                    const deltaY = event.clientY - this.lastMouseY;\n                    \n                    this.lastMouseX = event.clientX;\n                    this.lastMouseY = event.clientY;\n                      if (this.isRotating) {\n                        // Check for axis-specific rotation modes\n                        if (this.axisRotationMode === 'x') {\n                            // X-axis only rotation (pitch) - invert deltaY for natural movement\n                            this.sphericalDelta.phi -= deltaY * this.data.rotateSpeed * 0.002;\n                            this.showStatus(\"X-Axis Rotation Mode\");\n                        } else if (this.axisRotationMode === 'y') {\n                            // Y-axis only rotation (yaw) - invert deltaX for natural movement\n                            this.sphericalDelta.theta -= deltaX * this.data.rotateSpeed * 0.002;\n                            this.showStatus(\"Y-Axis Rotation Mode\");\n                        } else if (this.axisRotationMode === 'z') {\n                            // Z-axis rotation (roll) - rotate around the view direction\n                            const rollAmount = deltaX * this.data.rotateSpeed * 0.001;\n                            // Apply roll by adjusting both theta and phi in a coordinated way\n                            this.sphericalDelta.theta -= rollAmount * Math.cos(this.spherical.phi);\n                            this.sphericalDelta.phi -= rollAmount * Math.sin(this.spherical.phi);\n                            this.showStatus(\"Z-Axis Rotation Mode\");\n                        } else {\n                            // Check for modifier keys for temporary axis locking\n                            if (event.shiftKey) {\n                                // Shift + drag = X-axis only (pitch)\n                                this.sphericalDelta.phi -= deltaY * this.data.rotateSpeed * 0.002;\n                                this.showStatus(\"X-Axis Rotation (Hold Shift)\");\n                            } else if (event.ctrlKey || event.metaKey) {\n                                // Ctrl + drag = Y-axis only (yaw)\n                                this.sphericalDelta.theta -= deltaX * this.data.rotateSpeed * 0.002;\n                                this.showStatus(\"Y-Axis Rotation (Hold Ctrl)\");\n                            } else if (event.altKey) {\n                                // Alt + drag = Z-axis rotation (roll)\n                                const rollAmount = deltaX * this.data.rotateSpeed * 0.001;\n                                this.sphericalDelta.theta -= rollAmount * Math.cos(this.spherical.phi);\n                                this.sphericalDelta.phi -= rollAmount * Math.sin(this.spherical.phi);\n                                this.showStatus(\"Z-Axis Rotation (Hold Alt)\");\n                            } else {\n                                // Normal free rotation - CORRECTED: proper direction for natural camera movement\n                                this.sphericalDelta.theta -= deltaX * this.data.rotateSpeed * 0.002;\n                                this.sphericalDelta.phi -= deltaY * this.data.rotateSpeed * 0.002;\n                            }\n                        }\n                    } else if (this.isPanning) {\n                        // Pan\n                        this.handlePan(deltaX, deltaY);\n                    }\n                },\n                \n                handlePan: function(deltaX, deltaY) {\n                    const el = this.cameraEl;\n                    const position = el.getAttribute('position');\n                    const distance = new THREE.Vector3(position.x, position.y, position.z).distanceTo(this.target);\n                    \n                    // Calculate pan speed based on distance\n                    const panSpeed = Math.max(0.05, Math.min(1.0, distance / 20)) * this.panSpeed;\n                    \n                    // Calculate pan based on camera orientation\n                    const lookDir = new THREE.Vector3(0, 0, -1);\n                    lookDir.applyQuaternion(el.object3D.quaternion);\n                    \n                    const rightDir = new THREE.Vector3(1, 0, 0);\n                    rightDir.applyQuaternion(el.object3D.quaternion);\n                    \n                    const upDir = new THREE.Vector3(0, 1, 0);\n                    upDir.applyQuaternion(el.object3D.quaternion);\n                    \n                    const pan = new THREE.Vector3();\n                    pan.addScaledVector(rightDir, -deltaX * panSpeed * 0.003);\n                    pan.addScaledVector(upDir, deltaY * panSpeed * 0.003);\n                    \n                    this.panOffset.add(pan);\n                },\n                \n                onMouseUp: function() {\n                    document.removeEventListener('mousemove', this.onMouseMove);\n                    document.removeEventListener('mouseup', this.onMouseUp);\n                    \n                    this.isRotating = false;\n                    this.isPanning = false;\n                },\n                  onMouseWheel: function(event) {\n                    event.preventDefault();\n                    \n                    if (!this.data.enableZoom) return;\n                    \n                    // Normalize wheel delta across browsers\n                    const SCROLL_FACTOR = 0.01;\n                    let delta = 0;\n                    \n                    if (event.wheelDelta !== undefined) {\n                        // WebKit / Opera / Explorer 9\n                        delta = event.wheelDelta;\n                    } else if (event.detail !== undefined) {\n                        // Firefox\n                        delta = -event.detail * 40;\n                    } else if (event.deltaY !== undefined) {\n                        // Standard\n                        delta = -event.deltaY;\n                        \n                        // Handle different units\n                        if (event.deltaMode === 1) {\n                            // DOM_DELTA_LINE: multiply by 40 (40 pixels per line)\n                            delta *= 40;\n                        } else if (event.deltaMode === 2) {\n                            // DOM_DELTA_PAGE: multiply by viewport height\n                            delta *= window.innerHeight;\n                        }\n                    }\n                    \n                    // Normalize and apply smoother zooming\n                    delta = Math.sign(delta) * Math.min(Math.abs(delta * SCROLL_FACTOR), 0.25);\n                    \n                    // Calculate zoom scale with adaptive sensitivity based on distance\n                    const distance = this.spherical.radius;\n                    const distanceFactor = Math.max(0.5, Math.min(1.5, distance / 10)); // Adjust based on current distance\n                    const zoomScale = Math.pow(0.95, delta * this.data.zoomSpeed * distanceFactor);\n                    \n                    this.scale *= zoomScale;\n                    this.zoomChanged = true;\n                    \n                    if (delta > 0) {\n                        this.showStatus(\"Zooming In\");\n                    } else {\n                        this.showStatus(\"Zooming Out\");\n                    }\n                },\n                  onTouchStart: function(event) {\n                    event.preventDefault();\n                    \n                    if (event.touches.length === 1) {\n                        // Single touch - rotate\n                        this.isRotating = true;\n                        this.showStatus(\"Rotating\");\n                        \n                        this.lastMouseX = event.touches[0].clientX;\n                        this.lastMouseY = event.touches[0].clientY;\n                    } else if (event.touches.length === 2) {\n                        // Two touches - pinch to zoom and pan\n                        this.isZooming = true;\n                        \n                        // Calculate initial distance between touch points for pinch-zoom\n                        const dx = event.touches[0].clientX - event.touches[1].clientX;\n                        const dy = event.touches[0].clientY - event.touches[1].clientY;\n                        this.touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);\n                        \n                        // Midpoint for panning\n                        this.lastMouseX = (event.touches[0].clientX + event.touches[1].clientX) / 2;\n                        this.lastMouseY = (event.touches[0].clientY + event.touches[1].clientY) / 2;\n                        \n                        // Long touch with two fingers initiates panning\n                        this.touchStartTime = Date.now();\n                        this.touchPanTimeout = setTimeout(() => {\n                            if (this.isZooming) {\n                                this.isPanning = true;\n                                this.showStatus(\"Pan mode activated\");\n                            }\n                        }, 300); // 300ms to activate pan mode\n                    } else if (event.touches.length === 3) {\n                        // Three finger touch - reset camera\n                        this.showStatus(\"Resetting Camera\");\n                        const mathViz = window.mathViz;\n                        if (mathViz) {\n                            mathViz.resetCamera();\n                        }\n                    }\n                },\n                  onTouchMove: function(event) {\n                    event.preventDefault();\n                    \n                    if (this.isRotating && event.touches.length === 1) {\n                        // Single touch - rotate\n                        const deltaX = event.touches[0].clientX - this.lastMouseX;\n                        const deltaY = event.touches[0].clientY - this.lastMouseY;\n                        \n                        this.lastMouseX = event.touches[0].clientX;\n                        this.lastMouseY = event.touches[0].clientY;\n                        \n                        // Use a smoother rotation with smaller factor for touch\n                        const touchFactor = 0.8; // Reduce sensitivity for touch\n                          // Apply axis-specific rotation for touch\n                        if (this.axisRotationMode === 'x') {\n                            // X-axis only rotation (pitch) - corrected direction\n                            this.sphericalDelta.phi -= deltaY * this.data.rotateSpeed * 0.002 * touchFactor;\n                            this.showStatus(\"Touch X-Axis Rotation Mode\");\n                        } else if (this.axisRotationMode === 'y') {\n                            // Y-axis only rotation (yaw) - corrected direction\n                            this.sphericalDelta.theta -= deltaX * this.data.rotateSpeed * 0.002 * touchFactor;\n                            this.showStatus(\"Touch Y-Axis Rotation Mode\");\n                        } else if (this.axisRotationMode === 'z') {\n                            // Z-axis rotation (roll) - corrected calculation\n                            const rollAmount = deltaX * this.data.rotateSpeed * 0.001 * touchFactor;\n                            this.sphericalDelta.theta -= rollAmount * Math.cos(this.spherical.phi);\n                            this.sphericalDelta.phi -= rollAmount * Math.sin(this.spherical.phi);\n                            this.showStatus(\"Touch Z-Axis Rotation Mode\");\n                        } else {\n                            // Normal free rotation - CORRECTED: proper direction for natural camera movement\n                            this.sphericalDelta.theta -= deltaX * this.data.rotateSpeed * 0.002 * touchFactor;\n                            this.sphericalDelta.phi -= deltaY * this.data.rotateSpeed * 0.002 * touchFactor;\n                        }\n                    } else if (this.isZooming && event.touches.length === 2) {\n                        // Calculate current distance between touch points\n                        const dx = event.touches[0].clientX - event.touches[1].clientX;\n                        const dy = event.touches[0].clientY - event.touches[1].clientY;\n                        const touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);\n                        \n                        // Calculate zoom factor - how much to zoom in/out\n                        const factor = this.touchZoomDistanceStart / touchZoomDistanceEnd;\n                        \n                        // Apply zoom with a smoother factor\n                        const zoomFactor = Math.max(0.9, Math.min(1.1, factor)); // Limit extreme changes\n                        this.scale *= zoomFactor;\n                        this.zoomChanged = true;\n                        this.touchZoomDistanceStart = touchZoomDistanceEnd;\n                        \n                        // Handle panning during pinch if in pan mode\n                        if (this.isPanning) {\n                            const midpointX = (event.touches[0].clientX + event.touches[1].clientX) / 2;\n                            const midpointY = (event.touches[0].clientY + event.touches[1].clientY) / 2;\n                            \n\n                            const panDeltaX = midpointX - this.lastMouseX;\n                            const panDeltaY = midpointY - this.lastMouseY;\n                            \n                            this.lastMouseX = midpointX;\n                            this.lastMouseY = midpointY;\n                              // Apply pan with a smoother factor for touch\n                            this.handlePan(panDeltaX * 0.7, panDeltaY * 0.7);\n                            \n\n                            this.showStatus(\"Panning & Zooming\");\n                        } else {\n                            if (factor < 1) {\n                                this.showStatus(\"Zooming Out\");\n                            } else {\n                                this.showStatus(\"Zooming In\");\n                            }\n                        }\n                    }\n                },\n                \n                onTouchEnd: function(event) {\n                    clearTimeout(this.touchPanTimeout);\n                    \n                    // Add a little inertia on touch end\n                    if (this.data.enableInertia) {\n                        if (this.isRotating) {\n                            this.wasRotating = true;\n                        }\n                        if (this.isPanning) {\n                            this.wasPanning = true;\n                        }\n                    }\n                    \n                    this.isRotating = false;\n                    this.isZooming = false;\n                    this.isPanning = false;\n                    \n                    // If one finger remains after multi-touch, go back to rotation\n                    if (event.touches.length === 1) {\n                        this.isRotating = true;\n                        this.lastMouseX = event.touches[0].clientX;\n                        this.lastMouseY = event.touches[0].clientY;\n                        this.showStatus(\"Rotating\");\n                    }\n                },\n                  onKeyDown: function(event) {\n                    if (!this.data.enableKeys) return;\n                    \n                    const keySpeed = 0.05;\n                    \n                    switch (event.key.toLowerCase()) {\n                        case 'arrowup':\n                            this.panOffset.y += keySpeed;\n                            break;\n                        case 'arrowdown':\n                            this.panOffset.y -= keySpeed;\n                            break;\n                        case 'arrowleft':\n                            this.panOffset.x -= keySpeed;\n                            break;\n                        case 'arrowright':\n                            this.panOffset.x += keySpeed;\n                            break;\n                        case '+':\n                        case '=':\n                            this.scale *= 0.9;\n                            this.zoomChanged = true;\n                            this.showStatus(\"Zooming In\");\n                            break;\n                        case '-':\n                        case '_':\n                            this.scale *= 1.1;\n                            this.zoomChanged = true;\n                            this.showStatus(\"Zooming Out\");\n                            break;\n                        \n                        // Axis-specific rotation mode toggles\n                        case 'x':\n                            if (this.axisRotationMode === 'x') {\n                                this.axisRotationMode = null;\n                                this.showStatus(\"Free Rotation Mode\", 2000);\n                            } else {\n                                this.axisRotationMode = 'x';\n                                this.showStatus(\"X-Axis Rotation Mode\", 2000);\n                            }\n                            break;\n                        case 'y':\n                            if (this.axisRotationMode === 'y') {\n                                this.axisRotationMode = null;\n                                this.showStatus(\"Free Rotation Mode\", 2000);\n                            } else {\n                                this.axisRotationMode = 'y';\n                                this.showStatus(\"Y-Axis Rotation Mode\", 2000);\n                            }\n                            break;\n                        case 'z':\n                            if (this.axisRotationMode === 'z') {\n                                this.axisRotationMode = null;\n                                this.showStatus(\"Free Rotation Mode\", 2000);\n                            } else {\n                                this.axisRotationMode = 'z';\n                                this.showStatus(\"Z-Axis Rotation Mode\", 2000);\n                            }\n                            break;\n                        case 'r':\n                            // Reset to free rotation mode\n                            this.axisRotationMode = null;\n                            this.showStatus(\"Free Rotation Mode\", 2000);\n                            break;\n                    }\n                }\n            });\n            }\n            \n            // Register mouse-cursor component to provide visible cursor\n            if (!AFRAME.components['mouse-cursor']) {\n                AFRAME.registerComponent('mouse-cursor', {\n                init: function () {\n                    this.cursor = document.createElement('div');\n                    this.cursor.style.cssText = `\n                        position: absolute;\n                        width: 20px;\n                        height: 20px;\n                        border: 2px solid white;\n                        border-radius: 50%;\n                        transform: translate(-50%, -50%);\n                        pointer-events: none;\n                        z-index: 9999;\n                        display: none;\n                    `;\n                    document.body.appendChild(this.cursor);\n                    \n                    this.onMouseMove = this.onMouseMove.bind(this);\n                    this.onMouseDown = this.onMouseDown.bind(this);\n                    this.onMouseUp = this.onMouseUp.bind(this);\n                    this.onMouseEnter = this.onMouseEnter.bind(this);\n                    this.onMouseLeave = this.onMouseLeave.bind(this);\n                    \n                    document.addEventListener('mousemove', this.onMouseMove);\n                    document.addEventListener('mousedown', this.onMouseDown);\n                    document.addEventListener('mouseup', this.onMouseUp);\n                    \n                    const canvas = document.querySelector('canvas');\n                    if (canvas) {\n                        canvas.addEventListener('mouseenter', this.onMouseEnter);\n                        canvas.addEventListener('mouseleave', this.onMouseLeave);\n                    }\n                },\n                \n                remove: function () {\n                    document.removeEventListener('mousemove', this.onMouseMove);\n                    document.removeEventListener('mousedown', this.onMouseDown);\n                    document.removeEventListener('mouseup', this.onMouseUp);\n                    \n                    const canvas = document.querySelector('canvas');\n                    if (canvas) {\n                        canvas.removeEventListener('mouseenter', this.onMouseEnter);\n                        canvas.removeEventListener('mouseleave', this.onMouseLeave);\n                    }\n                    \n                    if (this.cursor) {\n                        this.cursor.remove();\n                    }\n                },\n                \n                onMouseMove: function (evt) {\n                    this.cursor.style.left = `${evt.clientX}px`;\n                    this.cursor.style.top = `${evt.clientY}px`;\n                },\n                \n                onMouseDown: function () {\n                    this.cursor.style.borderColor = '#4CAF50';\n                },\n                  onMouseUp: function () {\n                    this.cursor.style.borderColor = 'white';\n                },\n                  onMouseEnter: function () {\n                    this.cursor.style.display = 'block';\n                },                  onMouseLeave: function () {\n                    this.cursor.style.display = 'none';\n                }\n            });\n              setTimeout(() => initializeVisualizer(), 500);\n        };\n    } else {\n        // A-Frame already loaded, initialize directly\n        initializeVisualizer();\n    }\n    \n    function initializeVisualizer() {\n        container.innerHTML = `\n            <div id=\"controls-panel\" style=\"\n                position: absolute;\n                top: 10px;\n                left: 10px;\n                background: rgba(0, 0, 0, 0.9);\n                color: white;\n                padding: 15px;\n                border-radius: 8px;\n                z-index: 1000;\n                max-width: 280px;\n                max-height: 500px;\n                overflow-y: auto;\n                font-family: Arial, sans-serif;\n                font-size: 12px;\n            \">\n                <h3 style=\"margin: 0 0 15px 0; color: #4CAF50;\">3D Math Visualizer</h3>\n                  <!-- Vector Controls -->\n                <div class=\"control-section\" style=\"margin-bottom: 15px; padding: 10px; border: 1px solid #333; border-radius: 5px;\">\n                    <h4 style=\"margin: 0 0 8px 0; color: #4CAF50;\">Vectors</h4>\n                    <div style=\"display: flex; align-items: center; margin-bottom: 4px;\">\n                        <label style=\"color: #ccc; font-size: 11px; width: 20px; margin-right: 5px;\">X:</label>\n                        <input type=\"number\" id=\"vx\" placeholder=\"X component\" value=\"3\" step=\"0.1\" style=\"width: 70%; margin: 2px; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 3px;\">\n                    </div>\n                    <div style=\"display: flex; align-items: center; margin-bottom: 4px;\">\n                        <label style=\"color: #ccc; font-size: 11px; width: 20px; margin-right: 5px;\">Y:</label>\n                        <input type=\"number\" id=\"vy\" placeholder=\"Y component\" value=\"2\" step=\"0.1\" style=\"width: 70%; margin: 2px; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 3px;\">\n                    </div>\n                    <div style=\"display: flex; align-items: center; margin-bottom: 4px;\">\n                        <label style=\"color: #ccc; font-size: 11px; width: 20px; margin-right: 5px;\">Z:</label>\n                        <input type=\"number\" id=\"vz\" placeholder=\"Z component\" value=\"1\" step=\"0.1\" style=\"width: 70%; margin: 2px; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 3px;\">\n                    </div>\n                    <div style=\"display: flex; align-items: center; margin-bottom: 4px;\">\n                        <label style=\"color: #ccc; font-size: 11px; width: 40px; margin-right: 5px;\">Color:</label>\n                        <input type=\"color\" id=\"vcolor\" value=\"#ff0000\" style=\"width: 50%; margin: 2px; padding: 2px; background: #333; border: 1px solid #555; border-radius: 3px;\">\n                    </div>\n                    <button onclick=\"mathViz.addVector()\" style=\"width: 100%; margin: 2px; padding: 6px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer;\">Add Vector</button>\n                    <div id=\"vector-list\"></div>\n                </div>\n                  <!-- Explicit Surface Controls -->\n                <div class=\"control-section\" style=\"margin-bottom: 15px; padding: 10px; border: 1px solid #333; border-radius: 5px;\">\n                    <h4 style=\"margin: 0 0 8px 0; color: #4CAF50;\">Explicit Surface z = f(x,y)</h4>\n                    <div style=\"margin-bottom: 4px;\">\n                        <label style=\"color: #ccc; font-size: 11px; display: block; margin-bottom: 2px;\">Function f(x,y):</label>\n                        <input type=\"text\" id=\"explicit-func\" placeholder=\"e.g., x*x + y*y or sin(sqrt(x^2 + y^2))\" value=\"sin(sqrt(x*x + y*y))\" style=\"width: 95%; margin: 2px; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 3px;\">\n                    </div>\n                    <div style=\"display: flex; gap: 5px; margin-bottom: 4px;\">\n                        <div style=\"flex: 1;\">\n                            <label style=\"color: #ccc; font-size: 11px; display: block; margin-bottom: 2px;\">Range:</label>\n                            <input type=\"number\" id=\"explicit-range\" placeholder=\"Range\" value=\"3\" step=\"0.1\" style=\"width: 100%; margin: 2px; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 3px;\">\n                        </div>\n                        <div style=\"flex: 1;\">\n                            <label style=\"color: #ccc; font-size: 11px; display: block; margin-bottom: 2px;\">Resolution:</label>\n                            <input type=\"number\" id=\"explicit-res\" placeholder=\"Grid size\" value=\"20\" min=\"5\" max=\"50\" style=\"width: 100%; margin: 2px; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 3px;\">\n                        </div>\n                        <div style=\"flex: 0.5;\">\n                            <label style=\"color: #ccc; font-size: 11px; display: block; margin-bottom: 2px;\">Color:</label>\n                            <input type=\"color\" id=\"explicit-color\" value=\"#00ff00\" style=\"width: 100%; margin: 2px; padding: 2px; background: #333; border: 1px solid #555; border-radius: 3px;\">\n                        </div>\n                    </div>\n                    <button onclick=\"mathViz.addExplicitSurface()\" style=\"width: 100%; margin: 2px; padding: 6px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer;\">Add Surface</button>\n                    <div id=\"explicit-list\"></div>\n                </div>\n                  <!-- Parametric Surface Controls -->\n                <div class=\"control-section\" style=\"margin-bottom: 15px; padding: 10px; border: 1px solid #333; border-radius: 5px;\">\n                    <h4 style=\"margin: 0 0 8px 0; color: #4CAF50;\">Parametric Surface (x(u,v), y(u,v), z(u,v))</h4>\n                    <div style=\"margin-bottom: 4px;\">\n                        <label style=\"color: #ccc; font-size: 11px; display: block; margin-bottom: 2px;\">X Function x(u,v):</label>\n                        <input type=\"text\" id=\"param-x\" placeholder=\"e.g., u*cos(v) or (2+cos(u))*cos(v)\" value=\"u*cos(v)\" style=\"width: 95%; margin: 2px; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 3px;\">\n                    </div>\n                    <div style=\"margin-bottom: 4px;\">\n                        <label style=\"color: #ccc; font-size: 11px; display: block; margin-bottom: 2px;\">Y Function y(u,v):</label>\n                        <input type=\"text\" id=\"param-y\" placeholder=\"e.g., u*sin(v) or (2+cos(u))*sin(v)\" value=\"u*sin(v)\" style=\"width: 95%; margin: 2px; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 3px;\">\n                    </div>\n                    <div style=\"margin-bottom: 4px;\">\n                        <label style=\"color: #ccc; font-size: 11px; display: block; margin-bottom: 2px;\">Z Function z(u,v):</label>\n                        <input type=\"text\" id=\"param-z\" placeholder=\"e.g., u or sin(u) or u*v\" value=\"u\" style=\"width: 95%; margin: 2px; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 3px;\">\n                    </div>\n                    <div style=\"display: flex; gap: 2px; margin-bottom: 4px;\">\n                        <div style=\"flex: 1;\">\n                            <label style=\"color: #ccc; font-size: 11px; display: block; margin-bottom: 2px;\">u Min:</label>\n                            <input type=\"number\" id=\"param-umin\" placeholder=\"u min\" value=\"0\" step=\"0.1\" style=\"width: 100%; margin: 1px; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 3px;\">\n                        </div>\n                        <div style=\"flex: 1;\">\n                            <label style=\"color: #ccc; font-size: 11px; display: block; margin-bottom: 2px;\">u Max:</label>\n                            <input type=\"number\" id=\"param-umax\" placeholder=\"u max\" value=\"2\" step=\"0.1\" style=\"width: 100%; margin: 1px; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 3px;\">\n                        </div>\n                        <div style=\"flex: 1;\">\n                            <label style=\"color: #ccc; font-size: 11px; display: block; margin-bottom: 2px;\">v Min:</label>\n                            <input type=\"number\" id=\"param-vmin\" placeholder=\"v min\" value=\"0\" step=\"0.1\" style=\"width: 100%; margin: 1px; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 3px;\">\n                        </div>\n                        <div style=\"flex: 1;\">\n                            <label style=\"color: #ccc; font-size: 11px; display: block; margin-bottom: 2px;\">v Max:</label>\n                            <input type=\"number\" id=\"param-vmax\" placeholder=\"v max\" value=\"6.28\" step=\"0.1\" style=\"width: 100%; margin: 1px; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 3px;\">\n                        </div>\n                    </div>\n                    <div style=\"display: flex; gap: 5px; margin-bottom: 4px;\">\n                        <div style=\"flex: 1;\">\n                            <label style=\"color: #ccc; font-size: 11px; display: block; margin-bottom: 2px;\">Resolution:</label>\n                            <input type=\"number\" id=\"param-res\" placeholder=\"Grid size\" value=\"15\" min=\"5\" max=\"30\" style=\"width: 100%; margin: 2px; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 3px;\">\n                        </div>\n                        <div style=\"flex: 0.5;\">\n                            <label style=\"color: #ccc; font-size: 11px; display: block; margin-bottom: 2px;\">Color:</label>\n                            <input type=\"color\" id=\"param-color\" value=\"#0000ff\" style=\"width: 100%; margin: 2px; padding: 2px; background: #333; border: 1px solid #555; border-radius: 3px;\">\n                        </div>\n                    </div>\n                    <button onclick=\"mathViz.addParametricSurface()\" style=\"width: 100%; margin: 2px; padding: 6px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer;\">Add Parametric Surface</button>\n                    <div id=\"param-list\"></div>\n                </div>\n                  <!-- Implicit Surface Controls -->\n                <div class=\"control-section\" style=\"margin-bottom: 15px; padding: 10px; border: 1px solid #333; border-radius: 5px;\">\n                    <h4 style=\"margin: 0 0 8px 0; color: #4CAF50;\">Implicit Surface f(x,y,z) = 0</h4>\n                    <div style=\"margin-bottom: 4px;\">\n                        <label style=\"color: #ccc; font-size: 11px; display: block; margin-bottom: 2px;\">Function f(x,y,z):</label>\n                        <input type=\"text\" id=\"implicit-func\" placeholder=\"e.g., x*x + y*y + z*z - 4 or x^2 + y^2 + z^2 - 4\" value=\"x*x + y*y + z*z - 4\" style=\"width: 95%; margin: 2px; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 3px;\">\n                    </div>\n                    <div style=\"display: flex; gap: 5px; margin-bottom: 4px;\">\n                        <div style=\"flex: 1;\">\n                            <label style=\"color: #ccc; font-size: 11px; display: block; margin-bottom: 2px;\">Range:</label>\n                            <input type=\"number\" id=\"implicit-range\" placeholder=\"Range\" value=\"3\" step=\"0.1\" style=\"width: 100%; margin: 2px; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 3px;\">\n                        </div>\n                        <div style=\"flex: 1;\">\n                            <label style=\"color: #ccc; font-size: 11px; display: block; margin-bottom: 2px;\">Resolution:</label>\n                            <input type=\"number\" id=\"implicit-res\" placeholder=\"Grid density\" value=\"12\" min=\"5\" max=\"20\" style=\"width: 100%; margin: 2px; padding: 4px; background: #333; color: white; border: 1px solid #555; border-radius: 3px;\">\n                        </div>\n                        <div style=\"flex: 0.5;\">\n                            <label style=\"color: #ccc; font-size: 11px; display: block; margin-bottom: 2px;\">Color:</label>\n                            <input type=\"color\" id=\"implicit-color\" value=\"#ffff00\" style=\"width: 100%; margin: 2px; padding: 2px; background: #333; border: 1px solid #555; border-radius: 3px;\">\n                        </div>\n                    </div>\n                    <button onclick=\"mathViz.addImplicitSurface()\" style=\"width: 100%; margin: 2px; padding: 6px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer;\">Add Implicit Surface</button>\n                    <div id=\"implicit-list\"></div>\n                </div>\n                  <!-- Camera Controls -->\n                <div style=\"display: flex; justify-content: space-between; margin-top: 15px;\">\n                    <button onclick=\"mathViz.zoomIn()\" style=\"width: 31%; padding: 8px; background: #2196F3; color: white; border: none; border-radius: 3px; cursor: pointer;\">Zoom In</button>\n                    <button onclick=\"mathViz.resetCamera()\" style=\"width: 31%; padding: 8px; background: #2196F3; color: white; border: none; border-radius: 3px; cursor: pointer;\">Reset Camera</button>\n                    <button onclick=\"mathViz.zoomOut()\" style=\"width: 31%; padding: 8px; background: #2196F3; color: white; border: none; border-radius: 3px; cursor: pointer;\">Zoom Out</button>\n                </div>\n                <button onclick=\"mathViz.clearAll()\" style=\"width: 100%; padding: 8px; background: #f44336; color: white; border: none; border-radius: 3px; cursor: pointer; margin-top: 10px;\">Clear All</button>\n            </div>            <div style=\"position: absolute; bottom: 10px; left: 10px; background: rgba(0, 0, 0, 0.8); color: white; padding: 8px; border-radius: 5px; font-size: 11px; z-index: 1000;\">\n                <strong>Controls:</strong> Left-click: Rotate | Right-click: Pan | Scroll/Pinch: Zoom | 3 Fingers: Reset Camera<br>\n                <strong>Axis Rotation:</strong> Shift+Drag: X-axis only | Ctrl+Drag: Y-axis only | Alt+Drag: Z-axis only<br>\n                <strong>Toggle Lock:</strong> X/Y/Z keys: Lock to axis | R key: Free rotation\n            </div>\n            \n            <a-scene embedded style=\"height: 100%; width: 100%;\">\n                <a-sky color=\"#001122\"></a-sky>\n                \n                <a-light type=\"ambient\" color=\"#404040\"></a-light>\n                <a-light type=\"directional\" position=\"5 5 5\" color=\"#ffffff\" intensity=\"0.8\"></a-light>\n                <a-light type=\"directional\" position=\"-5 -5 -5\" color=\"#ffffff\" intensity=\"0.4\"></a-light>                  <a-entity id=\"camera-rig\" position=\"6 6 6\">\n                    <a-camera id=\"main-camera\" orbit-controls=\"\n                        target: 0 0 0;\n                        enableDamping: true;\n                        dampingFactor: 0.25;\n                        rotateSpeed: 0.5;\n                        minDistance: 2;\n                        maxDistance: 20;\n                        enablePan: true;\n                        panSpeed: 0.5;\n                        minPolarAngle: 0.2;\n                        maxPolarAngle: 2.5;\n                        enableKeys: true;\n                        enableZoom: true;\n                        zoomSpeed: 1.0;\n                        enableInertia: true;\n                        inertiaFactor: 0.9;\"\n                        mouse-cursor=\"\">\n                    </a-camera>\n                </a-entity>\n                \n                <!-- 3D Axes -->\n                <a-entity id=\"axes\">\n                    <!-- X-axis (red) -->\n                    <a-cylinder position=\"2.5 0 0\" rotation=\"0 0 90\" radius=\"0.02\" height=\"5\" color=\"red\"></a-cylinder>\n                    <a-cone position=\"5 0 0\" rotation=\"0 0 -90\" radius-bottom=\"0.08\" radius-top=\"0\" height=\"0.25\" color=\"red\"></a-cone>\n                    <a-text position=\"5.3 0 0\" value=\"X\" color=\"red\" scale=\"1.5 1.5 1.5\"></a-text>\n                    \n                    <!-- Y-axis (green) -->\n                    <a-cylinder position=\"0 2.5 0\" radius=\"0.02\" height=\"5\" color=\"green\"></a-cylinder>\n                    <a-cone position=\"0 5 0\" radius-bottom=\"0.08\" radius-top=\"0\" height=\"0.25\" color=\"green\"></a-cone>\n                    <a-text position=\"0 5.3 0\" value=\"Y\" color=\"green\" scale=\"1.5 1.5 1.5\"></a-text>\n                    \n                    <!-- Z-axis (blue) -->\n                    <a-cylinder position=\"0 0 2.5\" rotation=\"90 0 0\" radius=\"0.02\" height=\"5\" color=\"blue\"></a-cylinder>\n                    <a-cone position=\"0 0 5\" rotation=\"90 0 0\" radius-bottom=\"0.08\" radius-top=\"0\" height=\"0.25\" color=\"blue\"></a-cone>\n                    <a-text position=\"0 0 5.3\" value=\"Z\" color=\"blue\" scale=\"1.5 1.5 1.5\"></a-text>\n                    \n                    <!-- Grid -->\n                    <a-entity id=\"grid-container\"></a-entity>\n                </a-entity>\n                \n                <a-entity id=\"math-objects\"></a-entity>\n            </a-scene>        `;\n        \n        // Initialize the math visualizer object first\n        window.mathViz = new MathVisualizer();\n        window.mathViz.createGrid();\n        \n        // Wait for A-Frame to be ready before creating grid and objects\n        setTimeout(() => {\n            if (window.mathViz && typeof window.mathViz.createGrid === 'function') {\n                window.mathViz.createGrid();\n            }\n        }, 1000);\n    }\n    \n    // If container is not in DOM, append it\n    if (!document.getElementById(containerId)) {\n        document.body.appendChild(container);\n    }\n    \n    return container;\n}\n\n//**********************************************************************\n// MathVisualizer Class - Core Functionality\n//**********************************************************************\n\nclass MathVisualizer {\n    constructor() {\n        this.vectorCount = 0;\n        this.surfaceCount = 0;\n        this.objects = [];\n    }\n      \n    //**********************************************************************\n    // Grid Creation & Math Expression Evaluation\n    //**********************************************************************\n    createGrid() {\n        const gridContainer = document.getElementById('grid-container');\n        if (!gridContainer) {\n            console.warn('Grid container not found, skipping grid creation');\n            return;\n        }\n        \n        const gridSize = 8;\n        const gridStep = 1;\n        const lineRadius = 0.005;\n        \n        // Clear any existing grid\n        gridContainer.innerHTML = '';\n        \n        for (let i = -gridSize; i <= gridSize; i += gridStep) {\n            if (i === 0) continue; // Skip center lines (axes handle these)\n              // **XY PLANE GRIDLINES** (Z = 0)\n            // Lines parallel to X-axis (varying Y positions)\n            const xyLineX = document.createElement('a-cylinder');\n            xyLineX.setAttribute('position', `0 ${i} 0`);\n            xyLineX.setAttribute('rotation', '0 0 90'); // Rotate to align with X-axis\n            xyLineX.setAttribute('radius', lineRadius);\n            xyLineX.setAttribute('height', gridSize * 2);\n            xyLineX.setAttribute('color', '#ffffff');\n            xyLineX.setAttribute('opacity', '0.25');\n            gridContainer.appendChild(xyLineX);\n            \n            // Lines parallel to Y-axis (varying X positions)\n            const xyLineY = document.createElement('a-cylinder');\n            xyLineY.setAttribute('position', `${i} 0 0`);\n            xyLineY.setAttribute('rotation', '0 0 0'); // Default Y-axis alignment\n            xyLineY.setAttribute('radius', lineRadius);\n            xyLineY.setAttribute('height', gridSize * 2);\n            xyLineY.setAttribute('color', '#ffffff');\n            xyLineY.setAttribute('opacity', '0.25');\n            gridContainer.appendChild(xyLineY);\n            \n            // **YZ PLANE GRIDLINES** (X = 0)\n            // Lines parallel to Y-axis (varying Z positions)\n            const yzLineY = document.createElement('a-cylinder');\n            yzLineY.setAttribute('position', `0 0 ${i}`);\n            yzLineY.setAttribute('rotation', '0 0 0'); // Default Y-axis alignment\n            yzLineY.setAttribute('radius', lineRadius);\n            yzLineY.setAttribute('height', gridSize * 2);\n            yzLineY.setAttribute('color', '#ffffff');\n            yzLineY.setAttribute('opacity', '0.2');\n            gridContainer.appendChild(yzLineY);\n            \n            // Lines parallel to Z-axis (varying Y positions)\n            const yzLineZ = document.createElement('a-cylinder');\n            yzLineZ.setAttribute('position', `0 ${i} 0`);\n            yzLineZ.setAttribute('rotation', '90 0 0'); // Rotate to align with Z-axis\n            yzLineZ.setAttribute('radius', lineRadius);\n            yzLineZ.setAttribute('height', gridSize * 2);\n            yzLineZ.setAttribute('color', '#ffffff');\n            yzLineZ.setAttribute('opacity', '0.2');\n            gridContainer.appendChild(yzLineZ);\n            \n            // **ZX PLANE GRIDLINES** (Y = 0)\n            // Lines parallel to Z-axis (varying X positions)\n            const zxLineZ = document.createElement('a-cylinder');\n            zxLineZ.setAttribute('position', `${i} 0 0`);\n            zxLineZ.setAttribute('rotation', '90 0 0'); // Rotate to align with Z-axis\n            zxLineZ.setAttribute('radius', lineRadius);\n            zxLineZ.setAttribute('height', gridSize * 2);\n            zxLineZ.setAttribute('color', '#ffffff');\n            zxLineZ.setAttribute('opacity', '0.2');\n            gridContainer.appendChild(zxLineZ);\n            \n            // Lines parallel to X-axis (varying Z positions)\n            const zxLineX = document.createElement('a-cylinder');\n            zxLineX.setAttribute('position', `0 0 ${i}`);\n            zxLineX.setAttribute('rotation', '0 0 90'); // Rotate to align with X-axis\n            zxLineX.setAttribute('radius', lineRadius);\n            zxLineX.setAttribute('height', gridSize * 2);\n            zxLineX.setAttribute('color', '#ffffff');\n            zxLineX.setAttribute('opacity', '0.2');\n            gridContainer.appendChild(zxLineX);\n        }\n          // Add some additional fine gridlines for better reference (half-step intervals)\n        const fineGridStep = 0.5;\n        for (let i = -gridSize + fineGridStep; i < gridSize; i += gridStep) {\n            // XY plane fine lines (lighter)\n            const fineLineX = document.createElement('a-cylinder');\n            fineLineX.setAttribute('position', `0 ${i} 0`);\n            fineLineX.setAttribute('rotation', '0 0 90');\n            fineLineX.setAttribute('radius', lineRadius * 0.6);\n            fineLineX.setAttribute('height', gridSize * 2);\n            fineLineX.setAttribute('color', '#ffffff');\n            fineLineX.setAttribute('opacity', '0.1');\n            gridContainer.appendChild(fineLineX);\n            \n            const fineLineY = document.createElement('a-cylinder');\n            fineLineY.setAttribute('position', `${i} 0 0`);\n            fineLineY.setAttribute('rotation', '0 0 0');\n            fineLineY.setAttribute('radius', lineRadius * 0.6);\n            fineLineY.setAttribute('height', gridSize * 2);\n            fineLineY.setAttribute('color', '#ffffff');\n            fineLineY.setAttribute('opacity', '0.1');\n            gridContainer.appendChild(fineLineY);\n        }\n          console.log('Comprehensive 3D grid created with XY, YZ, and ZX plane gridlines');\n    }\n\n    //**********************************************************************\n    // Math Expression Evaluation\n    //**********************************************************************\n      \n    evaluateExpression(expr, variables) {\n        // Convert exponent notation (^) to Math.pow\n        expr = this.convertExponents(expr);\n        \n        // Replace mathematical functions with Math object methods\n        expr = expr.replace(/sin/g, 'Math.sin');\n        expr = expr.replace(/cos/g, 'Math.cos');\n        expr = expr.replace(/tan/g, 'Math.tan');\n        expr = expr.replace(/asin|arcsin/g, 'Math.asin');\n        expr = expr.replace(/acos|arccos/g, 'Math.acos');\n        expr = expr.replace(/atan|arctan/g, 'Math.atan');\n        expr = expr.replace(/atan2/g, 'Math.atan2');\n        expr = expr.replace(/sinh/g, 'Math.sinh');\n        expr = expr.replace(/cosh/g, 'Math.cosh');\n        expr = expr.replace(/tanh/g, 'Math.tanh');\n        expr = expr.replace(/sqrt/g, 'Math.sqrt');\n        expr = expr.replace(/abs/g, 'Math.abs');\n        expr = expr.replace(/exp/g, 'Math.exp');\n        expr = expr.replace(/log/g, 'Math.log');\n        expr = expr.replace(/log10/g, 'Math.log10');\n        expr = expr.replace(/ln/g, 'Math.log'); // Natural logarithm\n        expr = expr.replace(/pow/g, 'Math.pow');\n        \n        // Replace mathematical constants\n        expr = expr.replace(/\\bpi\\b/g, 'Math.PI');\n        expr = expr.replace(/\\be\\b/g, 'Math.E');\n        \n        // Additional math functions\n        expr = expr.replace(/floor/g, 'Math.floor');\n        expr = expr.replace(/ceil/g, 'Math.ceil');\n        expr = expr.replace(/round/g, 'Math.round');\n        expr = expr.replace(/max/g, 'Math.max');\n        expr = expr.replace(/min/g, 'Math.min');\n        expr = expr.replace(/sign/g, 'Math.sign');\n        \n        // Replace variables\n        for (const [key, value] of Object.entries(variables)) {\n            const regex = new RegExp(`\\\\b${key}\\\\b`, 'g');\n            expr = expr.replace(regex, value);\n        }\n        \n        try {\n            return eval(expr);\n        } catch (e) {\n            console.error('Expression evaluation error:', e, 'in expression:', expr);\n            // Show the error to the user\n            const errorMsg = document.createElement('div');\n            errorMsg.style.cssText = 'background: #ff5252; color: white; padding: 10px; margin: 10px 0; border-radius: 4px; font-size: 12px;';\n            errorMsg.textContent = `Error in expression: ${e.message}`;\n            \n            // Show the error message temporarily\n            const controlsPanel = document.getElementById('controls-panel');\n            if (controlsPanel) {\n                controlsPanel.appendChild(errorMsg);\n                setTimeout(() => errorMsg.remove(), 5000);\n            }\n            return 0;\n        }\n    }\n    \n    // Convert exponent notation (^) to Math.pow calls\n    convertExponents(expr) {\n        // Handle nested exponents and parentheses properly\n        // This regex matches expressions like: x^2, (x+y)^3, sin(x)^2, etc.\n        const exponentPattern = /([a-zA-Z_$][a-zA-Z0-9_$]*|\\([^)]+\\)|Math\\.[a-zA-Z]+\\([^)]*\\)|\\d+(?:\\.\\d+)?)\\s*\\^\\s*([a-zA-Z_$][a-zA-Z0-9_$]*|\\([^)]+\\)|Math\\.[a-zA-Z]+\\([^)]*\\)|\\d+(?:\\.\\d+)?)/g;\n        \n        // Keep applying the pattern until no more matches (handles nested exponents)\n        let prevExpr = '';\n        while (prevExpr !== expr) {\n            prevExpr = expr;\n            expr = expr.replace(exponentPattern, 'Math.pow($1, $2)');\n        }\n          return expr;\n    }\n\n    //**********************************************************************\n    // Vector Visualization\n    //**********************************************************************\n    addVector() {\n        const vxEl = document.getElementById('vx');\n        const vyEl = document.getElementById('vy');\n        const vzEl = document.getElementById('vz');\n        const vcolorEl = document.getElementById('vcolor');\n        \n        if (!vxEl || !vyEl || !vzEl || !vcolorEl) {\n            console.error('Vector input elements not found');\n            return;\n        }\n        \n        const x = parseFloat(vxEl.value) || 0;\n        const y = parseFloat(vyEl.value) || 0;\n        const z = parseFloat(vzEl.value) || 0;\n        const color = vcolorEl.value;\n        \n        const vectorId = `vector-${this.vectorCount++}`;\n        const length = Math.sqrt(x*x + y*y + z*z);\n        \n        if (length === 0) {\n            console.warn('Cannot create zero-length vector');\n            return;\n        }\n        \n        const vectorEntity = document.createElement('a-entity');\n        vectorEntity.setAttribute('id', vectorId);\n        \n        // Create direction vector and normalize it\n        const direction = new THREE.Vector3(x, y, z);\n        const normalizedDirection = direction.clone().normalize();\n        \n        // Calculate rotation using quaternion for proper alignment\n        // A-Frame cylinders are aligned along Y-axis by default\n        const up = new THREE.Vector3(0, 1, 0);\n        const quaternion = new THREE.Quaternion();\n        quaternion.setFromUnitVectors(up, normalizedDirection);\n        \n        // Convert quaternion to Euler angles for A-Frame\n        const euler = new THREE.Euler();\n        euler.setFromQuaternion(quaternion, 'XYZ');        // Convert to degrees\n        const rotX = THREE.MathUtils.radToDeg(euler.x);\n        const rotY = THREE.MathUtils.radToDeg(euler.y);\n        const rotZ = THREE.MathUtils.radToDeg(euler.z);\n        \n        // Professional vector design with proper proportions\n        const arrowHeadLength = Math.max(0.3, length * 0.15); // Proportional but minimum size\n        const arrowHeadRadius = Math.max(0.08, length * 0.05); // Proportional radius\n        const shaftRadius = Math.max(0.03, length * 0.02); // Proportional shaft thickness\n        \n        // Calculate shaft length (total length minus arrowhead length)\n        const shaftLength = length - arrowHeadLength;\n        \n        // Shaft: positioned from origin to shaft end\n        const shaft = document.createElement('a-cylinder');\n        const shaftCenter = normalizedDirection.clone().multiplyScalar(shaftLength / 2);\n        shaft.setAttribute('position', `${shaftCenter.x} ${shaftCenter.y} ${shaftCenter.z}`);\n        shaft.setAttribute('radius', shaftRadius);\n        shaft.setAttribute('height', shaftLength);\n        shaft.setAttribute('color', color);\n        shaft.setAttribute('rotation', `${rotX} ${rotY} ${rotZ}`);\n        \n        // Arrowhead: positioned exactly at the end, perfectly aligned\n        const arrowHead = document.createElement('a-cone');\n        const headCenter = normalizedDirection.clone().multiplyScalar(length - (arrowHeadLength / 2));\n        arrowHead.setAttribute('position', `${headCenter.x} ${headCenter.y} ${headCenter.z}`);\n        arrowHead.setAttribute('radius-bottom', arrowHeadRadius);\n        arrowHead.setAttribute('radius-top', '0.01'); // Slight tip for better appearance\n        arrowHead.setAttribute('height', arrowHeadLength);\n        arrowHead.setAttribute('color', color);\n        arrowHead.setAttribute('rotation', `${rotX} ${rotY} ${rotZ}`);        \n        // Add a small sphere at the origin to show vector starting point\n        const origin = document.createElement('a-sphere');\n        origin.setAttribute('position', '0 0 0');\n        origin.setAttribute('radius', Math.max(0.04, length * 0.015)); // Proportional origin marker\n        origin.setAttribute('color', color);\n        origin.setAttribute('opacity', '0.8');\n        \n        vectorEntity.appendChild(origin);\n        vectorEntity.appendChild(shaft);\n        vectorEntity.appendChild(arrowHead);\n        \n        document.getElementById('math-objects').appendChild(vectorEntity);\n        \n        // Add to list\n        const vectorList = document.getElementById('vector-list');\n        if (vectorList) {\n            const vectorItem = document.createElement('div');\n            vectorItem.style.cssText = 'background: #2a2a2a; padding: 5px; margin: 3px 0; border-radius: 3px; font-size: 11px;';\n            vectorItem.innerHTML = `\n                <span style=\"color: ${color};\"></span> (${x.toFixed(1)}, ${y.toFixed(1)}, ${z.toFixed(1)}) |v|=${length.toFixed(2)}\n                <button onclick=\"mathViz.removeObject('${vectorId}', this.parentElement)\" style=\"background: #f44336; color: white; border: none; padding: 2px 6px; margin-left: 5px; border-radius: 2px; font-size: 10px; cursor: pointer;\"></button>\n            `;\n            vectorList.appendChild(vectorItem);\n        }\n        \n        this.objects.push({id: vectorId, type: 'vector', element: vectorEntity});\n        \n        console.log(`Vector added: (${x}, ${y}, ${z}) with length ${length.toFixed(2)}`);\n    }\n    \n    //**********************************************************************\n    // Explicit Surface Visualization\n    //**********************************************************************\n      addExplicitSurface() {\n        const funcEl = document.getElementById('explicit-func');\n        const rangeEl = document.getElementById('explicit-range');\n        const resEl = document.getElementById('explicit-res');\n        const colorEl = document.getElementById('explicit-color');\n        \n        if (!funcEl || !rangeEl || !resEl || !colorEl) {\n            console.error('Explicit surface input elements not found');\n            return;\n        }\n        \n        const func = funcEl.value;\n        const range = parseFloat(rangeEl.value) || 3;\n        const resolution = parseInt(resEl.value) || 20;\n        const color = colorEl.value;\n        \n        const surfaceId = `surface-${this.surfaceCount++}`;\n        \n        // Create surface using individual triangles\n        const surfaceEntity = document.createElement('a-entity');\n        surfaceEntity.setAttribute('id', surfaceId);\n        \n        for (let i = 0; i < resolution; i++) {\n            for (let j = 0; j < resolution; j++) {\n                const x1 = (i / resolution) * 2 * range - range;\n                const y1 = (j / resolution) * 2 * range - range;\n                const x2 = ((i + 1) / resolution) * 2 * range - range;\n                const y2 = ((j + 1) / resolution) * 2 * range - range;\n                \n                const z1 = this.evaluateExpression(func, {x: x1, y: y1});\n                const z2 = this.evaluateExpression(func, {x: x2, y: y1});\n                const z3 = this.evaluateExpression(func, {x: x1, y: y2});\n                const z4 = this.evaluateExpression(func, {x: x2, y: y2});                // Create two triangles for each quad\n                const triangle1 = document.createElement('a-triangle');\n                triangle1.setAttribute('vertex-a', `${x1} ${y1} ${z1}`);\n                triangle1.setAttribute('vertex-b', `${x2} ${y1} ${z2}`);\n                triangle1.setAttribute('vertex-c', `${x1} ${y2} ${z3}`);\n                triangle1.setAttribute('color', color);\n                triangle1.setAttribute('opacity', '0.8');\n                triangle1.setAttribute('transparent', 'true');\n                triangle1.setAttribute('side', 'double');\n                \n                const triangle2 = document.createElement('a-triangle');\n                triangle2.setAttribute('vertex-a', `${x2} ${y1} ${z2}`);\n                triangle2.setAttribute('vertex-b', `${x2} ${y2} ${z4}`);\n                triangle2.setAttribute('vertex-c', `${x1} ${y2} ${z3}`);\n                triangle2.setAttribute('color', color);\n                triangle2.setAttribute('opacity', '0.8');\n                triangle2.setAttribute('transparent', 'true');\n                triangle2.setAttribute('side', 'double');\n                \n                surfaceEntity.appendChild(triangle1);\n                surfaceEntity.appendChild(triangle2);\n            }\n        }\n        \n        document.getElementById('math-objects').appendChild(surfaceEntity);\n        \n        // Add to list\n        const explicitList = document.getElementById('explicit-list');\n        if (explicitList) {\n            const surfaceItem = document.createElement('div');\n            surfaceItem.style.cssText = 'background: #2a2a2a; padding: 5px; margin: 3px 0; border-radius: 3px; font-size: 11px;';\n            surfaceItem.innerHTML = `\n                z = ${func}\n                <button onclick=\"mathViz.removeObject('${surfaceId}', this.parentElement)\" style=\"background: #f44336; color: white; border: none; padding: 2px 6px; margin-left: 5px; border-radius: 2px; font-size: 10px; cursor: pointer;\"></button>\n            `;\n            explicitList.appendChild(surfaceItem);\n        }\n        \n        this.objects.push({id: surfaceId, type: 'explicit', element: surfaceEntity});\n    }\n    \n    //**********************************************************************\n    // Parametric Surface Visualization\n    //**********************************************************************\n    \n    addParametricSurface() {\n        const xFunc = document.getElementById('param-x').value;\n        const yFunc = document.getElementById('param-y').value;\n        const zFunc = document.getElementById('param-z').value;\n        const uMin = parseFloat(document.getElementById('param-umin').value) || 0;\n        const uMax = parseFloat(document.getElementById('param-umax').value) || 1;\n        const vMin = parseFloat(document.getElementById('param-vmin').value) || 0;\n        const vMax = parseFloat(document.getElementById('param-vmax').value) || 1;\n        const resolution = parseInt(document.getElementById('param-res').value) || 15;\n        const color = document.getElementById('param-color').value;\n        \n        const surfaceId = `param-surface-${this.surfaceCount++}`;\n        \n        const surfaceEntity = document.createElement('a-entity');\n        surfaceEntity.setAttribute('id', surfaceId);\n        \n        for (let i = 0; i < resolution; i++) {\n            for (let j = 0; j < resolution; j++) {\n                const u1 = uMin + (i / resolution) * (uMax - uMin);\n                const v1 = vMin + (j / resolution) * (vMax - vMin);\n                const u2 = uMin + ((i + 1) / resolution) * (uMax - uMin);\n                const v2 = vMin + ((j + 1) / resolution) * (vMax - vMin);\n                \n                const x1 = this.evaluateExpression(xFunc, {u: u1, v: v1});\n                const y1 = this.evaluateExpression(yFunc, {u: u1, v: v1});\n                const z1 = this.evaluateExpression(zFunc, {u: u1, v: v1});\n                \n                const x2 = this.evaluateExpression(xFunc, {u: u2, v: v1});\n                const y2 = this.evaluateExpression(yFunc, {u: u2, v: v1});\n                const z2 = this.evaluateExpression(zFunc, {u: u2, v: v1});\n                \n                const x3 = this.evaluateExpression(xFunc, {u: u1, v: v2});\n                const y3 = this.evaluateExpression(yFunc, {u: u1, v: v2});\n                const z3 = this.evaluateExpression(zFunc, {u: u1, v: v2});\n                \n                const x4 = this.evaluateExpression(xFunc, {u: u2, v: v2});\n                const y4 = this.evaluateExpression(yFunc, {u: u2, v: v2});\n                const z4 = this.evaluateExpression(zFunc, {u: u2, v: v2});\n                \n                // Create triangles\n                const triangle1 = document.createElement('a-triangle');\n                triangle1.setAttribute('vertex-a', `${x1} ${y1} ${z1}`);\n                triangle1.setAttribute('vertex-b', `${x2} ${y2} ${z2}`);\n                triangle1.setAttribute('vertex-c', `${x3} ${y3} ${z3}`);\n                triangle1.setAttribute('color', color);\n                triangle1.setAttribute('opacity', '0.8');\n                triangle1.setAttribute('transparent', 'true');\n                triangle1.setAttribute('side', 'double');\n                \n                const triangle2 = document.createElement('a-triangle');\n                triangle2.setAttribute('vertex-a', `${x2} ${y2} ${z2}`);\n                triangle2.setAttribute('vertex-b', `${x4} ${y4} ${z4}`);\n                triangle2.setAttribute('vertex-c', `${x3} ${y3} ${z3}`);\n                triangle2.setAttribute('color', color);\n                triangle2.setAttribute('opacity', '0.8');\n                triangle2.setAttribute('transparent', 'true');\n                triangle2.setAttribute('side', 'double');\n                \n                surfaceEntity.appendChild(triangle1);\n                surfaceEntity.appendChild(triangle2);\n            }\n        }\n        \n        document.getElementById('math-objects').appendChild(surfaceEntity);\n        \n        // Add to list\n        const paramList = document.getElementById('param-list');\n        const surfaceItem = document.createElement('div');\n        surfaceItem.style.cssText = 'background: #2a2a2a; padding: 5px; margin: 3px 0; border-radius: 3px; font-size: 11px;';\n        surfaceItem.innerHTML = `\n            (${xFunc}, ${yFunc}, ${zFunc})\n            <button onclick=\"mathViz.removeObject('${surfaceId}', this.parentElement)\" style=\"background: #f44336; color: white; border: none; padding: 2px 6px; margin-left: 5px; border-radius: 2px; font-size: 10px; cursor: pointer;\"></button>\n        `;\n        paramList.appendChild(surfaceItem);\n        \n        this.objects.push({id: surfaceId, type: 'parametric', element: surfaceEntity});\n    }\n      //**********************************************************************\n    // Implicit Surface Visualization\n    //**********************************************************************\n    \n    // Convert implicit function to parametric form\n    convertImplicitToParametric(func) {\n        console.log('Attempting to convert implicit function to parametric:', func);\n        \n        // Clean and normalize the function\n        let cleanFunc = func.toLowerCase().replace(/\\s+/g, '');\n        \n        // Common implicit surface patterns and their parametric equivalents\n        const patterns = [\n            // Sphere: x^2 + y^2 + z^2 - r^2 = 0\n            {\n                pattern: /^x\\*x\\+y\\*y\\+z\\*z-(\\d+(?:\\.\\d+)?)=?0?$/,\n                parametric: (r) => ({\n                    x: `${Math.sqrt(r)} * sin(u) * cos(v)`,\n                    y: `${Math.sqrt(r)} * sin(u) * sin(v)`,\n                    z: `${Math.sqrt(r)} * cos(u)`,\n                    uMin: 0, uMax: Math.PI, vMin: 0, vMax: 2 * Math.PI\n                })\n            },\n            \n            // Sphere: x^2 + y^2 + z^2 = r^2\n            {\n                pattern: /^x\\*x\\+y\\*y\\+z\\*z=(\\d+(?:\\.\\d+)?)$/,\n                parametric: (r) => ({\n                    x: `${Math.sqrt(r)} * sin(u) * cos(v)`,\n                    y: `${Math.sqrt(r)} * sin(u) * sin(v)`,\n                    z: `${Math.sqrt(r)} * cos(u)`,\n                    uMin: 0, uMax: Math.PI, vMin: 0, vMax: 2 * Math.PI\n                })\n            },\n            \n            // Cylinder: x^2 + y^2 - r^2 = 0\n            {\n                pattern: /^x\\*x\\+y\\*y-(\\d+(?:\\.\\d+)?)=?0?$/,\n                parametric: (r) => ({\n                    x: `${Math.sqrt(r)} * cos(u)`,\n                    y: `${Math.sqrt(r)} * sin(u)`,\n                    z: `v`,\n                    uMin: 0, uMax: 2 * Math.PI, vMin: -3, vMax: 3\n                })\n            },\n            \n            // Cylinder: x^2 + y^2 = r^2\n            {\n                pattern: /^x\\*x\\+y\\*y=(\\d+(?:\\.\\d+)?)$/,\n                parametric: (r) => ({\n                    x: `${Math.sqrt(r)} * cos(u)`,\n                    y: `${Math.sqrt(r)} * sin(u)`,\n                    z: `v`,\n                    uMin: 0, uMax: 2 * Math.PI, vMin: -3, vMax: 3\n                })\n            },\n            \n            // Cone: x^2 + y^2 - z^2 = 0\n            {\n                pattern: /^x\\*x\\+y\\*y-z\\*z=?0?$/,\n                parametric: () => ({\n                    x: `v * cos(u)`,\n                    y: `v * sin(u)`,\n                    z: `v`,\n                    uMin: 0, uMax: 2 * Math.PI, vMin: -2, vMax: 2\n                })\n            },\n            \n            // Ellipsoid: x^2/a^2 + y^2/b^2 + z^2/c^2 - 1 = 0\n            {\n                pattern: /^x\\*x\\/(\\d+(?:\\.\\d+)?)\\+y\\*y\\/(\\d+(?:\\.\\d+)?)\\+z\\*z\\/(\\d+(?:\\.\\d+)?)-1=?0?$/,\n                parametric: (a, b, c) => ({\n                    x: `${Math.sqrt(a)} * sin(u) * cos(v)`,\n                    y: `${Math.sqrt(b)} * sin(u) * sin(v)`,\n                    z: `${Math.sqrt(c)} * cos(u)`,\n                    uMin: 0, uMax: Math.PI, vMin: 0, vMax: 2 * Math.PI\n                })\n            },\n            \n            // Torus: (x^2 + y^2 + z^2 + R^2 - r^2)^2 - 4*R^2*(x^2 + y^2) = 0\n            // Simplified torus: (sqrt(x^2 + y^2) - R)^2 + z^2 - r^2 = 0\n            {\n                pattern: /torus|donut/i,\n                parametric: () => ({\n                    x: `(2 + cos(u)) * cos(v)`,\n                    y: `(2 + cos(u)) * sin(v)`,\n                    z: `sin(u)`,\n                    uMin: 0, uMax: 2 * Math.PI, vMin: 0, vMax: 2 * Math.PI\n                })\n            }\n        ];\n        \n        // Try to match patterns\n        for (const {pattern, parametric} of patterns) {\n            if (typeof pattern === 'string' && cleanFunc.includes(pattern)) {\n                return parametric();\n            } else if (pattern instanceof RegExp) {\n                const match = cleanFunc.match(pattern);\n                if (match) {\n                    console.log('Pattern matched:', pattern, 'with values:', match.slice(1));\n                    return parametric(...match.slice(1).map(Number));\n                }\n            }\n        }\n        \n        // If no pattern matches, try some general approaches\n        \n        // Check if it's a simple quadric surface that we can solve for z\n        if (cleanFunc.includes('z*z') && !cleanFunc.includes('x*z') && !cleanFunc.includes('y*z')) {\n            try {\n                // Try to solve for z as a function of x and y\n                // This is a simplified approach for surfaces like z^2 = x^2 + y^2\n                return {\n                    x: `u`,\n                    y: `v`, \n                    z: `sqrt(u*u + v*v)`, // This might not work for all cases\n                    uMin: -2, uMax: 2, vMin: -2, vMax: 2\n                };\n            } catch (e) {\n                console.log('Failed to convert to z=f(x,y) form');\n            }\n        }\n        \n        return null; // Conversion failed\n    }\n    \n    // Create parametric surface from the converted implicit function\n    createParametricFromImplicit(parametricForm, color, resolution = 20) {\n        console.log('Creating parametric surface with:', parametricForm);\n        \n        const surfaceId = `implicit-surface-${this.surfaceCount++}`;\n        const surfaceEntity = document.createElement('a-entity');\n        surfaceEntity.setAttribute('id', surfaceId);\n        \n        let triangleCount = 0;\n        \n        try {\n            for (let i = 0; i < resolution; i++) {\n                for (let j = 0; j < resolution; j++) {\n                    const u1 = parametricForm.uMin + (i / resolution) * (parametricForm.uMax - parametricForm.uMin);\n                    const v1 = parametricForm.vMin + (j / resolution) * (parametricForm.vMax - parametricForm.vMin);\n                    const u2 = parametricForm.uMin + ((i + 1) / resolution) * (parametricForm.uMax - parametricForm.uMin);\n                    const v2 = parametricForm.vMin + ((j + 1) / resolution) * (parametricForm.vMax - parametricForm.vMin);\n                    \n                    // Calculate the four corners of this patch\n                    const x1 = this.evaluateExpression(parametricForm.x, {u: u1, v: v1});\n                    const y1 = this.evaluateExpression(parametricForm.y, {u: u1, v: v1});\n                    const z1 = this.evaluateExpression(parametricForm.z, {u: u1, v: v1});\n                    \n                    const x2 = this.evaluateExpression(parametricForm.x, {u: u2, v: v1});\n                    const y2 = this.evaluateExpression(parametricForm.y, {u: u2, v: v1});\n                    const z2 = this.evaluateExpression(parametricForm.z, {u: u2, v: v1});\n                    \n                    const x3 = this.evaluateExpression(parametricForm.x, {u: u1, v: v2});\n                    const y3 = this.evaluateExpression(parametricForm.y, {u: u1, v: v2});\n                    const z3 = this.evaluateExpression(parametricForm.z, {u: u1, v: v2});\n                    \n                    const x4 = this.evaluateExpression(parametricForm.x, {u: u2, v: v2});\n                    const y4 = this.evaluateExpression(parametricForm.y, {u: u2, v: v2});\n                    const z4 = this.evaluateExpression(parametricForm.z, {u: u2, v: v2});\n                    \n                    // Check if all values are valid numbers\n                    if (isNaN(x1) || isNaN(y1) || isNaN(z1) || \n                        isNaN(x2) || isNaN(y2) || isNaN(z2) ||\n                        isNaN(x3) || isNaN(y3) || isNaN(z3) ||\n                        isNaN(x4) || isNaN(y4) || isNaN(z4)) {\n                        continue; // Skip invalid patches\n                    }\n                    \n                    // Create triangles\n                    const triangle1 = document.createElement('a-triangle');\n                    triangle1.setAttribute('vertex-a', `${x1} ${y1} ${z1}`);\n                    triangle1.setAttribute('vertex-b', `${x2} ${y2} ${z2}`);\n                    triangle1.setAttribute('vertex-c', `${x3} ${y3} ${z3}`);\n                    triangle1.setAttribute('color', color);\n                    triangle1.setAttribute('opacity', '0.8');\n                    triangle1.setAttribute('transparent', 'true');\n                    triangle1.setAttribute('side', 'double');\n                    \n                    const triangle2 = document.createElement('a-triangle');\n                    triangle2.setAttribute('vertex-a', `${x2} ${y2} ${z2}`);\n                    triangle2.setAttribute('vertex-b', `${x4} ${y4} ${z4}`);\n                    triangle2.setAttribute('vertex-c', `${x3} ${y3} ${z3}`);\n                    triangle2.setAttribute('color', color);\n                    triangle2.setAttribute('opacity', '0.8');\n                    triangle2.setAttribute('transparent', 'true');\n                    triangle2.setAttribute('side', 'double');\n                    \n                    surfaceEntity.appendChild(triangle1);\n                    surfaceEntity.appendChild(triangle2);\n                    triangleCount += 2;\n                }\n            }\n        } catch (error) {\n            console.error('Error creating parametric surface:', error);\n            throw error;\n        }\n        \n        return {surfaceEntity, triangleCount};\n    }    addImplicitSurface() {\n        const funcEl = document.getElementById('implicit-func');\n        const rangeEl = document.getElementById('implicit-range');\n        const resEl = document.getElementById('implicit-res');\n        const colorEl = document.getElementById('implicit-color');\n        \n        if (!funcEl || !rangeEl || !resEl || !colorEl) {\n            console.error('Implicit surface input elements not found');\n            return;\n        }\n        \n        const func = funcEl.value;\n        const range = parseFloat(rangeEl.value) || 3;\n        const resolution = parseInt(resEl.value) || 12;\n        const color = colorEl.value;\n        \n        if (!func.trim()) {\n            alert('Please enter an implicit function');\n            return;\n        }\n        \n        // Create loading indicator with progress bar\n        const loadingContainer = document.createElement('div');\n        loadingContainer.style.cssText = 'background: rgba(33, 33, 33, 0.9); color: white; padding: 15px; margin: 10px 0; border-radius: 4px; font-size: 12px;';\n        \n        const loadingText = document.createElement('div');\n        loadingText.textContent = 'Converting implicit function to parametric form...';\n        loadingContainer.appendChild(loadingText);\n        \n        const progressBarContainer = document.createElement('div');\n        progressBarContainer.style.cssText = 'width: 100%; height: 6px; background: #333; margin-top: 8px; border-radius: 3px; overflow: hidden;';\n        loadingContainer.appendChild(progressBarContainer);\n        \n        const progressBar = document.createElement('div');\n        progressBar.style.cssText = 'width: 20%; height: 100%; background: #4CAF50; transition: width 0.3s;';\n        progressBarContainer.appendChild(progressBar);\n        \n        document.getElementById('controls-panel').appendChild(loadingContainer);\n        \n        // Try to convert implicit function to parametric form\n        setTimeout(() => {\n            try {\n                progressBar.style.width = '40%';\n                loadingText.textContent = 'Analyzing implicit function...';\n                \n                const parametricForm = this.convertImplicitToParametric(func);\n                \n                if (parametricForm) {\n                    // Successfully converted to parametric form\n                    progressBar.style.width = '60%';\n                    loadingText.textContent = 'Generating smooth parametric surface...';\n                    \n                    setTimeout(() => {\n                        try {\n                            const result = this.createParametricFromImplicit(parametricForm, color, resolution);\n                            const surfaceEntity = result.surfaceEntity;\n                            const triangleCount = result.triangleCount;\n                            \n                            progressBar.style.width = '80%';\n                            loadingText.textContent = 'Adding surface to scene...';\n                            \n                            // Add to scene\n                            document.getElementById('math-objects').appendChild(surfaceEntity);\n                            \n                            // Add to list\n                            const implicitList = document.getElementById('implicit-list');\n                            const surfaceItem = document.createElement('div');\n                            surfaceItem.style.cssText = 'background: #2a2a2a; padding: 5px; margin: 3px 0; border-radius: 3px; font-size: 11px;';\n                            surfaceItem.innerHTML = `\n                                ${func} = 0 (${triangleCount} triangles, parametric)\n                                <button onclick=\"mathViz.removeObject('${surfaceEntity.id}', this.parentElement)\" style=\"background: #f44336; color: white; border: none; padding: 2px 6px; margin-left: 5px; border-radius: 2px; font-size: 10px; cursor: pointer;\"></button>\n                            `;\n                            implicitList.appendChild(surfaceItem);\n                            \n                            this.objects.push({id: surfaceEntity.id, type: 'implicit', element: surfaceEntity});\n                            \n                            // Success message\n                            progressBar.style.width = '100%';\n                            loadingText.textContent = 'Smooth implicit surface created successfully!';\n                            progressBar.style.background = '#4CAF50';\n                            \n                            setTimeout(() => loadingContainer.remove(), 1500);\n                        } catch (error) {\n                            console.error('Error creating parametric surface from implicit function:', error);\n                            this.fallbackToMarchingCubes(func, range, resolution, color, loadingContainer, progressBar, loadingText);\n                        }\n                    }, 100);\n                } else {\n                    // Could not convert to parametric form, fall back to marching cubes\n                    console.log('Could not convert to parametric form, using fallback approach');\n                    this.fallbackToMarchingCubes(func, range, resolution, color, loadingContainer, progressBar, loadingText);\n                }\n            } catch (error) {\n                console.error('Error in implicit surface conversion:', error);\n                this.fallbackToMarchingCubes(func, range, resolution, color, loadingContainer, progressBar, loadingText);\n            }\n        }, 50);\n    }\n      // Fallback method for unsupported implicit functions using Marching Cubes\n    fallbackToMarchingCubes(func, range, resolution, color, loadingContainer, progressBar, loadingText) {\n        progressBar.style.width = '30%';\n        loadingText.textContent = 'Using Marching Cubes algorithm...';\n        \n        const surfaceId = `implicit-surface-${this.surfaceCount++}`;\n        \n        setTimeout(() => {\n            try {\n                progressBar.style.width = '50%';\n                loadingText.textContent = 'Sampling voxel grid...';\n                \n                // Generate mesh using Marching Cubes\n                const mesh = this.generateMarchingCubesMesh(func, range, resolution, color);\n                \n                if (mesh) {\n                    progressBar.style.width = '80%';\n                    loadingText.textContent = 'Creating A-Frame surface...';\n                    \n                    // Convert THREE.js mesh to A-Frame entity\n                    const surfaceEntity = this.createAFrameFromThreeMesh(mesh, surfaceId, color);\n                    \n                    // Add to scene\n                    document.getElementById('math-objects').appendChild(surfaceEntity);\n                    \n                    // Add to list\n                    const implicitList = document.getElementById('implicit-list');\n                    const surfaceItem = document.createElement('div');\n                    surfaceItem.style.cssText = 'background: #2a2a2a; padding: 5px; margin: 3px 0; border-radius: 3px; font-size: 11px;';\n                    surfaceItem.innerHTML = `\n                        ${func} = 0 (${Math.floor(mesh.geometry.attributes.position.count / 3)} triangles, marching cubes)\n                        <button onclick=\"mathViz.removeObject('${surfaceId}', this.parentElement)\" style=\"background: #f44336; color: white; border: none; padding: 2px 6px; margin-left: 5px; border-radius: 2px; font-size: 10px; cursor: pointer;\"></button>\n                    `;\n                    implicitList.appendChild(surfaceItem);\n                    \n                    this.objects.push({id: surfaceId, type: 'implicit', element: surfaceEntity});\n                    \n                    // Success message\n                    progressBar.style.width = '100%';\n                    loadingText.textContent = `Marching Cubes surface created! (${Math.floor(mesh.geometry.attributes.position.count / 3)} triangles)`;\n                    progressBar.style.background = '#4CAF50';\n                    \n                    setTimeout(() => loadingContainer.remove(), 2000);\n                } else {\n                    throw new Error('Failed to generate mesh');\n                }\n                \n            } catch (error) {\n                console.error('Error in Marching Cubes generation:', error);\n                progressBar.style.background = '#f44336';\n                loadingText.textContent = 'Error: Could not generate surface. Check function syntax.';\n                setTimeout(() => loadingContainer.remove(), 3000);\n            }\n        }, 100);\n    }\n\n    //**********************************************************************\n    // Marching Cubes Implementation\n    //**********************************************************************\n    \n    // Generate mesh using Marching Cubes algorithm\n    generateMarchingCubesMesh(func, range, resolution, color) {\n        const vertices = [];\n        const normals = [];\n        \n        // Voxel grid\n        const step = (2 * range) / resolution;\n        const values = new Array(resolution + 1);\n        \n        // Sample function values at grid points\n        for (let i = 0; i <= resolution; i++) {\n            values[i] = new Array(resolution + 1);\n            for (let j = 0; j <= resolution; j++) {\n                values[i][j] = new Array(resolution + 1);\n                for (let k = 0; k <= resolution; k++) {\n                    const x = -range + i * step;\n                    const y = -range + j * step;\n                    const z = -range + k * step;\n                    \n                    try {\n                        values[i][j][k] = this.evaluateExpression(func, {x, y, z});\n                    } catch (e) {\n                        values[i][j][k] = 1; // Default to outside surface\n                    }\n                }\n            }\n        }\n        \n        // Process each cube in the grid\n        for (let i = 0; i < resolution; i++) {\n            for (let j = 0; j < resolution; j++) {\n                for (let k = 0; k < resolution; k++) {\n                    this.processCube(\n                        i, j, k, \n                        values, \n                        step, \n                        range, \n                        vertices, \n                        normals\n                    );\n                }\n            }\n        }\n        \n        if (vertices.length === 0) {\n            console.warn('No surface found in the given range');\n            return null;\n        }\n        \n        // Create THREE.js geometry\n        const geometry = new THREE.BufferGeometry();\n        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n        geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));\n        \n        // Compute vertex normals if not already computed\n        if (normals.length === 0) {\n            geometry.computeVertexNormals();\n        }\n        \n        // Create material\n        const material = new THREE.MeshStandardMaterial({\n            color: color,\n            side: THREE.DoubleSide,\n            transparent: true,\n            opacity: 0.8\n        });\n        \n        return new THREE.Mesh(geometry, material);\n    }\n    \n    // Process a single cube using Marching Cubes\n    processCube(i, j, k, values, step, range, vertices, normals) {\n        // Get the 8 corner values of the cube\n        const cubeValues = [\n            values[i][j][k],           // 0: bottom-left-back\n            values[i+1][j][k],         // 1: bottom-right-back\n            values[i+1][j+1][k],       // 2: top-right-back\n            values[i][j+1][k],         // 3: top-left-back\n            values[i][j][k+1],         // 4: bottom-left-front\n            values[i+1][j][k+1],       // 5: bottom-right-front\n            values[i+1][j+1][k+1],     // 6: top-right-front\n            values[i][j+1][k+1]        // 7: top-left-front\n        ];\n        \n        // Calculate cube index based on which vertices are inside/outside\n        let cubeIndex = 0;\n        for (let v = 0; v < 8; v++) {\n            if (cubeValues[v] < 0) { // Inside surface\n                cubeIndex |= (1 << v);\n            }\n        }\n        \n        // Get edge table entry for this cube configuration\n        const edges = this.getEdgeTable()[cubeIndex];\n        if (edges === 0) return; // No intersection\n        \n        // Calculate intersection points on cube edges\n        const edgeVertices = [];\n        for (let e = 0; e < 12; e++) {\n            if (edges & (1 << e)) {\n                const edgeInfo = this.getEdgeVertices()[e];\n                const v1 = edgeInfo[0];\n                const v2 = edgeInfo[1];\n                \n                const pos1 = this.getCubeVertexPosition(i, j, k, v1, step, range);\n                const pos2 = this.getCubeVertexPosition(i, j, k, v2, step, range);\n                \n                // Linear interpolation to find exact intersection point\n                const t = this.interpolate(cubeValues[v1], cubeValues[v2]);\n                const intersection = {\n                    x: pos1.x + t * (pos2.x - pos1.x),\n                    y: pos1.y + t * (pos2.y - pos1.y),\n                    z: pos1.z + t * (pos2.z - pos1.z)\n                };\n                \n                edgeVertices[e] = intersection;\n            }\n        }\n        \n        // Generate triangles using triangle table\n        const triangles = this.getTriangleTable()[cubeIndex];\n        for (let t = 0; t < triangles.length; t += 3) {\n            if (triangles[t] === -1) break;\n            \n            const v1 = edgeVertices[triangles[t]];\n            const v2 = edgeVertices[triangles[t + 1]];\n            const v3 = edgeVertices[triangles[t + 2]];\n            \n            // Add vertices\n            vertices.push(v1.x, v1.y, v1.z);\n            vertices.push(v2.x, v2.y, v2.z);\n            vertices.push(v3.x, v3.y, v3.z);\n            \n            // Calculate face normal\n            const normal = this.calculateNormal(v1, v2, v3);\n            normals.push(normal.x, normal.y, normal.z);\n            normals.push(normal.x, normal.y, normal.z);\n            normals.push(normal.x, normal.y, normal.z);\n        }\n    }\n    \n    // Get position of cube vertex\n    getCubeVertexPosition(i, j, k, vertex, step, range) {\n        const offsets = [\n            [0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0],\n            [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]\n        ];\n        \n        const offset = offsets[vertex];\n        return {\n            x: -range + (i + offset[0]) * step,\n            y: -range + (j + offset[1]) * step,\n            z: -range + (k + offset[2]) * step\n        };\n    }\n    \n    // Linear interpolation for edge intersection\n    interpolate(val1, val2) {\n        if (Math.abs(val1 - val2) < 0.00001) return 0.5;\n        return -val1 / (val2 - val1);\n    }\n    \n    // Calculate face normal from three vertices\n    calculateNormal(v1, v2, v3) {\n        const edge1 = {\n            x: v2.x - v1.x,\n            y: v2.y - v1.y,\n            z: v2.z - v1.z\n        };\n        const edge2 = {\n            x: v3.x - v1.x,\n            y: v3.y - v1.y,\n            z: v3.z - v1.z\n        };\n        \n        // Cross product\n        const normal = {\n            x: edge1.y * edge2.z - edge1.z * edge2.y,\n            y: edge1.z * edge2.x - edge1.x * edge2.z,\n            z: edge1.x * edge2.y - edge1.y * edge2.x\n        };\n        \n        // Normalize\n        const length = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);\n        if (length > 0) {\n            normal.x /= length;\n            normal.y /= length;\n            normal.z /= length;\n        }\n        \n        return normal;\n    }\n    \n    // Convert THREE.js mesh to A-Frame entity\n    createAFrameFromThreeMesh(mesh, entityId, color) {\n        const entity = document.createElement('a-entity');\n        entity.setAttribute('id', entityId);\n        \n        // Create geometry from mesh\n        const geometry = mesh.geometry;\n        const positions = geometry.attributes.position.array;\n        \n        // Create individual triangles for A-Frame\n        for (let i = 0; i < positions.length; i += 9) {\n            const triangle = document.createElement('a-triangle');\n            triangle.setAttribute('vertex-a', `${positions[i]} ${positions[i+1]} ${positions[i+2]}`);\n            triangle.setAttribute('vertex-b', `${positions[i+3]} ${positions[i+4]} ${positions[i+5]}`);\n            triangle.setAttribute('vertex-c', `${positions[i+6]} ${positions[i+7]} ${positions[i+8]}`);\n            triangle.setAttribute('color', color);\n            triangle.setAttribute('opacity', '0.8');\n            triangle.setAttribute('transparent', 'true');\n            triangle.setAttribute('side', 'double');\n            \n            entity.appendChild(triangle);\n        }\n          return entity;\n    }\n    \n    //**********************************************************************\n    // Marching Cubes Lookup Tables\n    //**********************************************************************\n    \n    // Edge table: defines which edges of a cube are intersected by the surface\n    getEdgeTable() {\n        return [\n            0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,\n            0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,\n            0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,\n            0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,\n            0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c,\n            0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,\n            0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac,\n            0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,\n            0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c,\n            0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,\n            0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc,\n            0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,\n            0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c,\n            0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,\n            0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc,\n            0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,\n            0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,\n            0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,\n            0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,\n            0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,\n            0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,\n            0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,\n            0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,\n            0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460,\n            0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,\n            0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0,\n            0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,\n            0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230,\n            0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,\n            0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190,\n            0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,\n            0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0\n        ];\n    }\n    \n    // Edge vertices: defines which vertices each edge connects\n    getEdgeVertices() {\n        return [\n            [0, 1], [1, 2], [2, 3], [3, 0], // bottom face edges\n            [4, 5], [5, 6], [6, 7], [7, 4], // top face edges\n            [0, 4], [1, 5], [2, 6], [3, 7]  // vertical edges\n        ];\n    }\n    \n    // Triangle table: defines triangles for each cube configuration\n    getTriangleTable() {\n        // Complete 256-entry triangle table for Marching Cubes\n        const table = new Array(256);\n        \n        // Initialize all entries as empty arrays\n        for (let i = 0; i < 256; i++) {\n            table[i] = [];\n        }\n        \n        // Add the complete triangle configurations\n        table[1] = [0, 8, 3];\n        table[2] = [0, 1, 9];\n        table[3] = [1, 8, 3, 9, 8, 1];\n        table[4] = [1, 2, 10];\n        table[5] = [0, 8, 3, 1, 2, 10];\n        table[6] = [9, 2, 10, 0, 2, 9];\n        table[7] = [2, 8, 3, 2, 10, 8, 10, 9, 8];\n        table[8] = [3, 11, 2];\n        table[9] = [0, 11, 2, 8, 11, 0];\n        table[10] = [1, 9, 0, 2, 3, 11];\n        table[11] = [1, 11, 2, 1, 9, 11, 9, 8, 11];\n        table[12] = [3, 10, 1, 11, 10, 3];\n        table[13] = [0, 10, 1, 0, 8, 10, 8, 11, 10];\n        table[14] = [3, 9, 0, 3, 11, 9, 11, 10, 9];\n        table[15] = [9, 8, 10, 10, 8, 11];\n        \n        // Add more key configurations to handle common cases\n        table[16] = [4, 7, 8];\n        table[17] = [4, 3, 0, 7, 3, 4];\n        table[18] = [0, 1, 9, 8, 4, 7];\n        table[19] = [4, 1, 9, 4, 7, 1, 7, 3, 1];\n        table[20] = [1, 2, 10, 8, 4, 7];\n        table[21] = [3, 4, 7, 3, 0, 4, 1, 2, 10];\n        table[22] = [9, 2, 10, 9, 0, 2, 8, 4, 7];\n        table[23] = [2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4];\n        table[24] = [8, 4, 7, 3, 11, 2];\n        table[25] = [11, 4, 7, 11, 2, 4, 2, 0, 4];\n        table[26] = [9, 0, 1, 8, 4, 7, 2, 3, 11];\n        table[27] = [4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1];\n        table[28] = [3, 10, 1, 3, 11, 10, 7, 8, 4];\n        table[29] = [1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4];\n        table[30] = [4, 7, 8, 9, 0, 3, 9, 3, 11, 9, 11, 10];\n        table[31] = [4, 7, 11, 4, 11, 9, 9, 11, 10];\n        \n        // For remaining entries, use symmetry and combinations\n        // This is a simplified implementation - a full implementation would have all 256 entries\n        for (let i = 32; i < 256; i++) {\n            if (table[i].length === 0) {\n                // For unknown configurations, try to derive from known ones\n                // or leave empty (no triangles)\n                const inverse = 255 - i; // Complement configuration\n                if (table[inverse] && table[inverse].length > 0) {\n                    // Use inverted triangle order for complement\n                    table[i] = table[inverse].slice().map((val, idx, arr) => {\n                        if (idx % 3 === 0) return arr[idx + 2];\n                        if (idx % 3 === 2) return arr[idx - 2];\n                        return val;\n                    });\n                }\n            }\n        }\n        \n        return table;\n    }\n    \n    //**********************************************************************\n    // Camera and Utility Functions\n    //**********************************************************************\n    \n    // Camera control methods\n    zoomIn() {\n        const camera = document.querySelector('#main-camera');\n        if (camera) {\n            const position = camera.getAttribute('position');\n            const distance = Math.sqrt(position.x*position.x + position.y*position.y + position.z*position.z);\n            const factor = 0.8;\n            camera.setAttribute('position', {\n                x: position.x * factor,\n                y: position.y * factor,\n                z: position.z * factor\n            });\n        }\n    }\n    \n    zoomOut() {\n        const camera = document.querySelector('#main-camera');\n        if (camera) {\n            const position = camera.getAttribute('position');\n            const factor = 1.25;\n            camera.setAttribute('position', {\n                x: position.x * factor,\n                y: position.y * factor,\n                z: position.z * factor\n            });\n        }\n    }\n    \n    resetCamera() {\n        const camera = document.querySelector('#main-camera');\n        if (camera) {\n            camera.setAttribute('position', '6 6 6');\n            camera.setAttribute('rotation', '0 0 0');\n        }\n    }\n    \n    // Object management\n    removeObject(objectId, listItem) {\n        // Remove from scene\n        const objectElement = document.getElementById(objectId);\n        if (objectElement) {\n            objectElement.remove();\n        }\n        \n        // Remove from list\n        if (listItem) {\n            listItem.remove();\n        }\n        \n        // Remove from objects array\n        this.objects = this.objects.filter(obj => obj.id !== objectId);\n    }\n    \n    clearAll() {\n        // Clear all mathematical objects\n        const mathObjects = document.getElementById('math-objects');\n        if (mathObjects) {\n            while (mathObjects.firstChild) {\n                mathObjects.removeChild(mathObjects.firstChild);\n            }\n        }\n        \n        // Clear object lists\n        ['vector-list', 'explicit-list', 'param-list', 'implicit-list'].forEach(listId => {\n            const list = document.getElementById(listId);\n            if (list) {\n                while (list.firstChild) {\n                    list.removeChild(list.firstChild);\n                }\n            }\n        });\n        \n        // Clear objects array\n        this.objects = [];\n    }\n    \n    // Helper method to format function expressions for display\n    formatFunction(func) {\n        return func.replace(/\\*/g, '').replace(/Math\\./g, '');\n    }\n    \n    // Initialize the axes visibility fix\n    initAxesVisibilityFix() {\n        // Check axes visibility periodically\n        setInterval(() => {\n            const axesEntity = document.getElementById('axes');\n            if (axesEntity) {\n                // Force the axes to be visible\n                if (!axesEntity.object3D.visible) {\n                    axesEntity.object3D.visible = true;\n                    console.log('Fixed axes visibility');\n                }\n                \n                // Check all children and ensure they're visible too\n                axesEntity.object3D.traverse(child => {\n                    if (child.isMesh && !child.visible) {\n                        child.visible = true;\n                        child.renderOrder = 2000;\n                        if (child.material) {\n                            child.material.depthTest = false;\n                            child.material.transparent = true;\n                            child.material.needsUpdate = true;\n                        }\n                    }\n                });\n                \n                // Ensure the axesEntity has a high render order\n                axesEntity.object3D.renderOrder = 2000;\n            }\n            \n            // Also check the grid container\n            const gridContainer = document.getElementById('grid-container');\n            if (gridContainer && !gridContainer.object3D.visible) {\n                gridContainer.object3D.visible = true;\n            }\n        }, 1000); // Reduced interval for more responsive visibility fixes\n    }\n}",
      "status": "[2]<br><span style=\"font-size:8px\">5ms<span></span></span>",
      "output": "",
      "type": "code"
    },
    {
      "code": "createMathVisualizer('visualizer-container');\n        \n        // Test adding a vector after initialization\n        setTimeout(() => {\n            console.log('Math visualizer initialized');\n            // You can now use mathViz to add objects programmatically\n },1000);",
      "status": "[3]<br><span style=\"font-size:8px\">41ms<span></span></span>",
      "output": "1099 <br>",
      "type": "code"
    },
    {
      "code": "",
      "status": "",
      "output": "",
      "type": "code"
    }
  ],
  "source": "https://github.com/gopi-suvanam/scribbler",
  "run_on_load": false
}